<?php
/**
 * @file
 * 
 * @todo Add filter on overview page.
 * @todo Add log view (with graph).
 * @todo Make proper markup for overview page.
 * @todo Re-add skip job if time windows exceeded.
 *
 * hook_cron_alter(&$hooks)
 * hook_cron_schedule_alter(&$hooks)
 * hook_cron_pre_execute($function, $hook)
 * hook_cron_pre_execute_FUNCTION($hook)
 * hook_cron_post_execute($function, $hook)
 * hook_cron_post_execute_FUNCTION($hook)
 */

/**
 * Maximum number of simultaneous connections.
 */
define('ULTIMATE_CRON_SIMULTANEOUS_CONNECTIONS', 40);

/**
 * Default rule.
 */
define('ULTIMATE_CRON_RULE',         '*/10 * * * *');

/**
 * Default rule for easy hook "hourly".
 */
define('ULTIMATE_CRON_HOURLY_RULE',  '0 * * * *');

/**
 * Default rule for easy hook "daily".
 */
define('ULTIMATE_CRON_DAILY_RULE',   '0 0 * * *');

/**
 * Default rule for easy hook "weekly".
 */
define('ULTIMATE_CRON_WEEKLY_RULE',  '0 0 * * 1');

/**
 * Default rule for easy hook "monthly".
 */
define('ULTIMATE_CRON_MONTHLY_RULE', '0 0 1 * *');

/**
 * Default rule for easy hook "yearly".
 */
define('ULTIMATE_CRON_YEARLY_RULE',  '0 0 1 1 *');

/**
 * Default max execution time for Ultimate Cron.
 */
define('ULTIMATE_CRON_MAX_EXECUTION_TIME', 86400);

/**
 * Default catch up time for Ultimate Cron.
 */
define('ULTIMATE_CRON_CATCH_UP', 300);

/**
 * Default clean up time for log entries (30 days).
 */
define('ULTIMATE_CRON_CLEANUP_LOG', 86400 * 30);

/**
 * Default setting for poorman.
 */
define('ULTIMATE_CRON_POORMAN', TRUE);

/**
 * Default queue polling latency.
 */
define('ULTIMATE_CRON_QUEUE_POLLING_LATENCY', '');

/**
 * Time in seconds to spend on launcing cron jobs.
 */
define('ULTIMATE_CRON_LAUNCH_WINDOW', 55);

// ---------- HOOKS ----------

/**
 * Implementation of hook_help().
 */
function ultimate_cron_help($path, $arg) {
  switch ($path) {
    case 'admin/help#ultimate_cron':
      // Return a line-break version of the module README
      return '<pre>'. file_get_contents( dirname(__FILE__) .'/README.txt') .'</pre>';
    case 'admin/build/cron':
      return '<p>'. t('Here you can see the crontab settings for each job available') .'</p>';
    case 'admin/build/cron/settings':
      return '<p>'. t('Here you can change the crontab settings for each job available') .'</p>';
  }
}

/**
 * Implementation of hook_menu().
 */
function ultimate_cron_menu() {
  $items = array();
  $items['admin/config/system/cron/settings'] = array(
    'title' => 'Settings',
    'description' => 'Cron settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('ultimate_cron_settings_form'),
    'access arguments' => array('administer ultimate cron'),
    'type' => MENU_LOCAL_TASK,
    'file' => 'ultimate_cron.admin.inc',
  );
  $items['admin/config/system/cron/settings/%'] = array(
    'title' => 'Settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('ultimate_cron_function_settings_form', 5),
    'access callback' => 'ultimate_cron_function_settings_form_access',
    'access arguments' => array(5),
    'weight' => 0,
    'file' => 'ultimate_cron.admin.inc',
  );
  $items['admin/reports/cron'] = array(
    'title' => 'Cron logs',
    'description' => 'View logs for all cron jobs.',
    'page callback' => 'ultimate_cron_view_page',
    'access arguments' => array('administer ultimate cron'),
    'file' => 'ultimate_cron.admin.inc',
  );
  $items['admin/reports/cron/%'] = array(
    'title' => 'Cron log',
    'description' => 'View log for specific function.',
    'page callback' => 'ultimate_cron_function_log_page',
    'page arguments' => array(3),
    'access callback' => 'ultimate_cron_function_settings_form_access',
    'access arguments' => array(3),
    'file' => 'ultimate_cron.admin.inc',
  );
  $items['admin/ultimate-cron/service/start/%'] = array(
    'type' => MENU_CALLBACK,
    'title' => 'Run cron job',
    'description' => 'Run cron job',
    'page callback' => 'ultimate_cron_service_start',
    'page arguments' => array(4),
    'access arguments' => array('administer ultimate cron'),
    'file' => 'ultimate_cron.admin.inc',
  );
  $items['admin/ultimate-cron/service/enable/%'] = array(
    'type' => MENU_CALLBACK,
    'title' => 'Enable cron job',
    'description' => 'Enable cron job',
    'page callback' => 'ultimate_cron_service_enable',
    'page arguments' => array(4, TRUE),
    'access arguments' => array('administer ultimate cron'),
    'file' => 'ultimate_cron.admin.inc',
  );
  $items['admin/ultimate-cron/service/disable/%'] = array(
    'type' => MENU_CALLBACK,
    'title' => 'Disable cron job',
    'description' => 'Disable cron job',
    'page callback' => 'ultimate_cron_service_enable',
    'page arguments' => array(4, FALSE),
    'access arguments' => array('administer ultimate cron'),
    'file' => 'ultimate_cron.admin.inc',
  );
  return $items;
}

/**
 * Implementation of hook_menu_alter().
 *
 * Steal the run-cron, so when you "run cron manually" from the status-reports
 * page the ultimate_cron cron handler is run.
 */
function ultimate_cron_menu_alter(&$items) {
  $items['admin/config/system/cron'] = array(
    'title' => 'Cron',
    'description' => 'View and manage cron table',
    'page callback' => 'ultimate_cron_view_page',
    'access arguments' => array('administer ultimate cron'),
    'module' => 'ultimate_cron',
    'file' => 'ultimate_cron.admin.inc',
  );
  $items['admin/config/system/cron/overview'] = array(
    'title' => 'List',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );
  $steal = &$items['admin/reports/status/run-cron'];
  $steal['page callback'] = 'ultimate_cron_run_cron';
  $steal['page arguments'] = array();
  $steal['module'] = 'ultimate_cron';
  $steal['file'] = 'ultimate_cron.admin.inc';
}

/**
 * Implementation of hook_perm().
 */
function ultimate_cron_permission() {
  return array(
    'administer ultimate cron' => array(
      'title' => t('Administer Ultimate Cron'),
      'description' => t('Lets you configure everything in Ultimate Cron')
    )
  );
}

/**
 * Implementation of hook_cron().
 *
 * The cron handler takes over the normal Drupal cron handler
 * and runs the normal hook_cron() plus the hook_cronapi().
 *
 * @param boolean $return
 *   return to caller if TRUE, otherwise exit().
 */
function ultimate_cron_cron($return = FALSE) {
  $msc = variable_get('ultimate_cron_simultaneous_connections', ULTIMATE_CRON_SIMULTANEOUS_CONNECTIONS);

  // Get list of cron hooks.
  $hooks = ultimate_cron_get_hooks();

  // If this is run manually and a lock can be acquired, then run unsafe hooks.
  $schedule_unsafe = $return && lock_acquire('cron', 240.0);
  // Get schedule.
  $schedule = ultimate_cron_get_schedule($hooks, $schedule_unsafe);
  drupal_set_message(t('%jobs jobs scheduled for launch', array('%jobs' => count($schedule))));

  // Start the jobs. Keep launching jobs until X seconds into the request.
  set_time_limit(120);
  $time = time();
  $expire = $time + variable_get('ultimate_cron_launch_window', ULTIMATE_CRON_LAUNCH_WINDOW);
  $running = array();
  $launched = 0;

  // Try to launch jobs within the given time frame
  while (!empty($schedule) && time() < $expire) {
    $running_processes = db_select('background_process', 'bp')
                          ->fields('bp', array('handle'))
                          ->condition('bp.handle', 'ultimate_cron:%', 'LIKE')
                          ->countQuery()
                          ->execute()
                          ->fetchField();
    // watchdog('ultimate_cron', "Jobs waiting to be launched: %jobs", array('%jobs' => count($schedule)), WATCHDOG_DEBUG);
    // Launch jobs.
    reset($schedule);
    while ($running_processes < $msc && (list($function, $hook) = each($schedule)) && time() < $expire) {
      $result = ultimate_cron_run_hook($function, $hook);

      // Handle errors.
      if ($result) {
        $handle = 'ultimate_cron:' . $hook['fid'];
        $running[$handle] = $result;
        unset($schedule[$function]);
        $launched++;
        $running_processes++;
      }
      else {
        if ($result === FALSE) {
          // Could not get lock, skip job.
          unset($schedule[$function]);
        }
        else {
          // Failed to start, retry next time.
          watchdog('ultimate_cron', "Error starting $function", array(), WATCHDOG_WARNING);
        }
      }
    }

    // Jobs running ... check for start
    // watchdog('ultimate_cron', "Jobs waiting to begin: %jobs", array('%jobs' => count($running)), WATCHDOG_DEBUG);
    if ($running) {
      $result = db_query("SELECT p.name FROM {progress} p WHERE p.name IN (:running)", array(':running' => array_keys($running)));
      while ($handle = $result->fetchObject()) {
        fclose($running[$handle->name]);
        unset($running[$handle->name]);
      }
    }
    sleep(1);
  }

  // Close all jobs left
  // watchdog('ultimate_cron', "Closing jobs: %jobs", array('%jobs' => count($running)), WATCHDOG_DEBUG);
  if ($running) {
    foreach (array_keys($running) as $handle) {
      fclose($running[$handle]);
      unset($running[$handle]);
    }
  }
  
  // Update drupals cron timestamp
  variable_set('cron_last', time());

  // Release the lock
  lock_release('cron');
  
  // And we're done ...
  if ($return) {
    drupal_set_message(t('%jobs jobs launched', array('%jobs' => $launched)));
    drupal_set_message(t('%jobs jobs failed to launch within %seconds seconds', array(
      '%jobs' => count($schedule), 
      '%seconds' => variable_get('ultimate_cron_launch_window', ULTIMATE_CRON_LAUNCH_WINDOW)
    )), empty($schedule) ? 'status' : 'error');
    return empty($schedule);
  }
  else {
    exit;
  }
}

/**
 * Implements hook_cronapi().
 */
function ultimate_cron_cronapi($op, $job = NULL) {
  // Grab the defined cron queues.
  static $queues = NULL;
  if (!isset($queues)) {
    $queues = module_invoke_all('cron_queue_info');
    drupal_alter('cron_queue_info', $queues);
  }

  switch ($op) {
    case 'list':
      $jobs['ultimate_cron_cleanup_log'] = t('Cleanup log entries');

      foreach ($queues as $queue_name => $info) {
        $jobs['ultimate_cron_queue_' . $queue_name] = t('Queue: %name', array('%name' => $queue_name));
      }
      return $jobs;
    case 'rule':
      $queue_name = str_replace('ultimate_cron_queue_', '', $job);
      if ($queue_name === $job) {
        return;
      }
      return '* * * * *';
    case 'execute':
      $queue_name = str_replace('ultimate_cron_queue_', '', $job);
      if ($queue_name === $job) {
        return;
      }

      $polling_latency = variable_get('ultimate_cron_queue_polling_latency', ULTIMATE_CRON_QUEUE_POLLING_LATENCY);
      $info = $queues[$queue_name];
      
      $function = $info['worker callback'];
      $end = time() + (isset($info['time']) ? $info['time'] : 15);
      $queue = DrupalQueue::get($queue_name);
      $items = 0;
      while (time() < $end) {
        $item = $queue->claimItem();
        if (!$item) {
          if (is_numeric($polling_latency)) {
            usleep($polling_latency);
            continue;
          }
          else {
            break;
          }
        }
        $function($item->data);
        $queue->deleteItem($item);
        $items++;
      }
      drupal_set_message(t('Processed @items items', array('@items' => $items)));
      if (is_numeric($polling_latency)) {
        background_process_keepalive();
      }
      return;
    case 'configure':
      return array(
        'ultimate_cron_cleanup_log' => 'admin/config/system/cron/settings',
        'dblog_cron' => 'admin/config/development/logging',
        'update_cron' => 'admin/reports/updates/settings',
      );
  }
}

/**
 * Implements hook_cron_alter().
 * Add better description to core modules.
 */
function ultimate_cron_cron_alter(&$hooks) {
  $update['dblog_cron'] = t('Remove expired log messages and flood control events');
  $update['field_cron'] = t('Purges deleted Field API data');
  $update['node_cron'] = t('Mark old nodes as read');
  $update['search_cron'] = t('Update indexes');
  $update['system_cron'] = t('Cleanup (batch, flood, temp-files, etc.)');
  foreach ($update as $function => $description) {
    if (isset($hooks[$function])) {
      $hooks[$function]['description'] = $description;
    }
  }
}

/**
 * Implementation of hook_requirements().
 */
function ultimate_cron_requirements($phase) {
  $response = array();
  switch ($phase) {
    case 'install':
      return $response;
    case 'runtime':
      $response['title'] = 'Ultimate Cron';
      $response['value'] = 'OK';
      if ($functions = ultimate_cron_unsafe_hooks()) {
        $response['severity'] = REQUIREMENT_WARNING;
        $response['value'] = t('Running in degraded mode');
        $response['description'] = t('Ultimate Cron is not the first module. Please change module weight to enable Ultimate Cron handling for all module.');
        $response['description'] .= '<br/>';
        $response['description'] .= t('Functions not handled by Ultimate Cron due to module weight, when cron is invoked through system crontab:<br/>%functions', array('%functions' => join(', ', array_keys($functions))));
      }
      $result = array();
      $result['ultimate_cron'] = $response;
      return $result;
  }
}

/**
 * Implements hook_theme_registry_alter().
 */
function ultimate_cron_theme_registry_alter(&$theme_registry) {
  $theme_registry['page']['theme paths'][] = drupal_get_path('module', 'ultimate_cron') . '/templates';
}

/**
 * Implementation of hook_watchdog().
 */
function ultimate_cron_watchdog($log = array()) {
  $record = &drupal_static('ultimate_cron_record', FALSE);
  if ($record && $log['severity'] <= WATCHDOG_WARNING) {
    $log['variables'] = is_array($log['variables']) ? $log['variables'] : array();
    ultimate_cron_record_log(t($log['message'], $log['variables']));
  }
}

/**
 * Implements hook_exit().
 */
function ultimate_cron_exit($destination = NULL) {
  // Launch poormans cron if applicable
  if (variable_get('ultimate_cron_poorman', ULTIMATE_CRON_POORMAN)) {
    $last = variable_get('cron_last', 0);
    $last = floor($last / 60) * 60;
    $time = time();
    $time = floor($time / 60) * 60;
    // Don't attempt, if already run within last minute
    if ($last < $time) {
      $handle = 'ultimate_cron_poorman';
      if ($process = background_process_get_process($handle)) {
        if ($process->start + 120 < time()) {
          // Must have timed out or something ... remove it!
          if (background_process_remove_process($handle, $process->start)) {
            $process = NULL;
          }
        }
      }
      if (!$process) {
        $process = new BackgroundProcess($handle);
        // Because anyone can launch poormans cron, run it as anonymous
        $process->uid = 0;
        $process->service_host = 'ultimate_cron_poorman';
        $result = $process->start('_ultimate_cron_poorman');
      }
    }
  }
}

/**
 * The actual poorman function
 * @return type 
 */
function _ultimate_cron_poorman() {
  if (!variable_get('ultimate_cron_poorman', ULTIMATE_CRON_POORMAN)) {
    return;
  }
  
  // Restart when done
  background_process_keepalive();

  // Derive current minute
  $time = time();
  $time = floor($time / 60) * 60;
  
  // Run the cron
  ultimate_cron_cron(TRUE);
  
  // Wait until end of "current" minute
  $wait = $time + 60 - time();
  if ($wait > 0 && $wait <= 60) {
    sleep($wait);
  }
}

// ---------- HELPER FUNCTIONS ----------

/**
 * Clean up log entries.
 */
function ultimate_cron_cleanup_log() {
  // return db_query_range("DELETE FROM {ultimate_cron_log} WHERE start < %d", time() - variable_get('ultimate_cron_cleanup_log', ULTIMATE_CRON_CLEANUP_LOG), 0, 1000);
}

/**
 * Access handler for function configuration.
 *
 * @param $function
 *   Function name.
 * @return boolean
 *   Access granted/denied.
 */
function ultimate_cron_function_settings_form_access($function) {
  if (!$function || !is_string($function)) {
    return FALSE;
  }

  $hooks = ultimate_cron_get_hooks();
  if (!isset($hooks[$function])) {
    return FALSE;
  }

  return user_access('administer ultimate cron');
}

/**
 * Run a cron hook.
 * Launches the cron job in a background process
 *
 * @param $function
 * @param $hook
 * @return mixed
 *   Connections file handle on success.
 */
function ultimate_cron_run_hook($function, $hook) {
  // Load configuration if not present
  ultimate_cron_load_hook_data($hook);

  // Run the job in background
  $result = NULL;
  $handle = "ultimate_cron:" . $hook['fid'];
  $process = new BackgroundProcess($handle);
  
  // Always run cron job as anonymous user
  $process->uid = 0;
  
  // Determine service group
  if (!empty($hook['configuration']['service_group'])) {
    $process->service_group = $hook['configuration']['service_group'];
  }
  $hook['timestamp'] = time();
  $result = $process->start('_ultimate_cron_run_hook', array($function, $hook));
  
  return $result ? $process->connection : $result;
}

/**
 * This is the function that is launched into a background process.
 * It runs the cron job and does housekeeping, pre/post execute hooks, etc.
 *
 * @param $module
 *   Module containing function.
 * @param $function
 *   Function to call.
 * @return boolean
 *   TRUE on success, FALSE on failure.
 */
function _ultimate_cron_run_hook($function, $hook) {
  set_time_limit(variable_get('ultimate_cron_max_execution_time', ULTIMATE_CRON_MAX_EXECUTION_TIME));
  drupal_save_session(FALSE);

  // Load current process
  $process = background_process_get_process(background_process_current_handle());

  $record = &drupal_static('ultimate_cron_record', FALSE);
  $record = TRUE;
  ultimate_cron_record_log(NULL, TRUE);

  // Load configuration if not present
  if (!isset($hook['log'])) {
    $hook['log'] = ultimate_cron_get_log($hook['fid']);
  }
  
  $time = time();
  if (empty($hook['skip_catch_up']) && !ultimate_cron_hook_should_run($hook)) {
    // Hook started too late!
    watchdog('ultimate_cron', '%function skipped. Invoked at %invoke, but did not start until %start', array(
      '%function' => $function,
      '%invoke' => format_date($hook['timestamp'], 'custom', 'Y-m-d H:i:s'),
      '%start' => format_date($time, 'custom', 'Y-m-d H:i:s'),
    ), WATCHDOG_ERROR);
    ultimate_cron_background_process_shutdown($process, FALSE);
    return FALSE;
  }

  // Let other modules do stuff before execution, if they need to.
  module_invoke_all('cron_pre_execute', $function, $hook);
  module_invoke_all('cron_pre_execute_' . $function, $hook);

  if (function_exists($function)) {
    $function();
  }
  else {
    module_invoke($hook['module'], 'cronapi', 'execute', $function);
  }

  ultimate_cron_background_process_shutdown($process, NULL);

  // Let other modules do stuff before execution, if they need to.
  module_invoke_all('cron_post_execute', $function, $hook);
  module_invoke_all('cron_post_execute_' . $function, $hook);

  return TRUE;
}

/**
 * Implements hook_background_process_shutdown().
 *
 * Shutdown handler for cronjobs.
 */
function ultimate_cron_background_process_shutdown($process, $result = NULL, $shutdown_msg = '') {
  $args = func_get_args();
  $fid = str_replace('ultimate_cron:', '', $process->handle);
  if (is_numeric($fid)) {
    static $has_run = array();
    if (!empty($has_run[$fid])) {
      return;
    }
    $has_run[$fid] = TRUE;

    $error = error_get_last();
    $fatal_msg = '';
    if ($error) { // && ($error['type'] & (E_ERROR | E_CORE_ERROR | E_RECOVERABLE_ERROR))) {
      $fatal_msg =  $error['message'] . ' (line ' . $error['line'] . ' of ' . $error['file'] . ').' . "\n";
    }
    $msg = ultimate_cron_record_log(NULL);
    if ($shutdown_msg) {
      $msg .= $msg ? "\n$shutdown_msg" : $shutdown_msg;
    }
    
    // Record end time
    $end = microtime(TRUE);

    $messages = drupal_get_messages(NULL, TRUE);
    if (!empty($messages['error'])) {
      $msg .= join("\n", $messages['error']) . "\n";
    }
    $msg .= $fatal_msg;
    
    // If result not set by cronjob, use watchdog errors (if any) as result.
    if ($result === NULL) {
      $result = empty($msg);
    }
    if ($result && empty($msg) && !empty($messages['status'])) {
      $msg = join("\n", $messages['status']) . "\n";
    }

    // If only one argument was passed to this function, assume it was called by
    // a shutdown handler, and conclude that something went wrong.
    // If no message has been recorded, provide a default one.
    if (func_num_args() == 1) {
      $result = FALSE;
      if (!$fatal_msg) {
        $msg .= t('Died unexpectedly');
      }
    }

    // log results here ...
    $object = (object)array(
      'fid' => $fid,
      'start' => $process->start,
      'end' => $end,
      'status' => $result,
      'msg' => $msg,
    );
    drupal_write_record('ultimate_cron_log', $object);
    $function = db_query("SELECT `function` FROM {ultimate_cron_function} WHERE fid = :fid", array(':fid' => $fid))->fetchField();
    // watchdog('ultimate_cron', 'Shutdown: %function (%result) - %msg', array('%function' => $function, '%result' => $result, '%msg' => $msg), WATCHDOG_DEBUG);
  }
}

/**
 * Get a list of functions that should be run now.
 *
 * @param $hooks
 *   Array of cron hooks to check.
 * @return array
 *   Functions to run now.
 */
function ultimate_cron_get_schedule($hooks, $schedule_unsafe = FALSE) {
  // Create list of scheduled functions
  $schedule = array();
  foreach ($hooks as $function => &$hook) {
    ultimate_cron_load_hook_data($hook);

    // Is it safe?
    if (!$schedule_unsafe && $hook['unsafe']) {
      continue;
    }
    
    // Store last run in hook for sorting purposes
    $last_run = isset($hook['log']['start']) ? $hook['log']['start'] : 0;
    $hook['last_run'] = $last_run;

    if (ultimate_cron_hook_should_run($hook)) {
      $schedule[$function] = $hook;
    }
  }

  // Sort by last run time
  uasort($schedule, '_ultimate_cron_sort_schedule');

  // Allow other to manipulate the schedule
  drupal_alter('cron_schedule', $schedule);

  return $schedule;
}

/**
 * Populate hook array with configuration and log data
 *
 * @param type $hook 
 */
function ultimate_cron_load_hook_data(&$hook) {
  // Get configuration
  if (!isset($hook['configuration'])) {
    $hook['configuration'] = ultimate_cron_get_configuration($hook['function']);
  }

  // Get log, used for checking last start time
  if (!isset($hook['log'])) {
    $hook['log'] = ultimate_cron_get_log($hook['fid']);
  }
}

/**
 * Check if a hook should be run now.
 *
 * @param array $hook
 * @return boolean
 */
function ultimate_cron_hook_should_run($hook) {
  // Is it enabled?
  if (!empty($hook['configuration']) && empty($hook['configuration']['enabled'])) {
    return FALSE;
  }

  // Use default values if necessary
  $rules = empty($hook['configuration']['rules']) ? $hook['rules'] : $hook['configuration']['rules'];
  if (isset($hook['configuration']['catch_up']) && is_numeric($hook['configuration']['catch_up'])) {
    $catch_up = $hook['configuration']['catch_up'];
  } else {
    $catch_up = variable_get('ultimate_cron_catch_up', ULTIMATE_CRON_CATCH_UP);
  }
  $last_run = isset($hook['log']['start']) ? $hook['log']['start'] : 0;

  return ultimate_cron_should_run($rules, $last_run, time(), $catch_up);
}

/**
 * Sort callback for ordering schedule.
 *
 * @param type $a
 * @param type $b
 * @return type 
 */
function _ultimate_cron_sort_schedule($a, $b) {
  return $a['last_run'] == $b['last_run'] ? 0 : ($a['last_run'] < $b['last_run'] ? -1 : 1);
}

/**
 * Get cron hooks available.
 *
 * @return array
 *   List of modules.
 */
function ultimate_cron_get_hooks() {
  static $hooks = NULL;
  if (isset($hooks)) {
    return $hooks;
  }
  $hooks = array();

  // Which modules are not hook_cron() safe?
  $uncronable_modules = ultimate_cron_uncronable_modules();
  
  // Generate list of hooks
  $modules = module_list();
  foreach ($modules as $module) {
    $file = drupal_get_path('module', $module) .'/'. $module .'.info';
    $info = drupal_parse_info_file($file);
    foreach (ultimate_cron_easy_hooks() as $hook => $description) {
      if (module_hook($module, $hook)) {
        $function = $module . '_' . $hook;
        $hooks[$function]['unsafe'] = (isset($uncronable_modules[$module]) && $hook === 'cron') ? TRUE : FALSE;
        $hooks[$function]['description'] = $description;
        $hooks[$function]['module'] = $module;
        $hooks[$function]['configure'] = isset($info['configure']) ? $info['configure'] : '';
        $hooks[$function]['rules'] = ultimate_cron_get_default_rules($module, $function, ultimate_cron_easy_hooks_rule($hook));
      }
    }
    if ($cronapi = module_invoke($module, 'cronapi', 'list')) {
      foreach ($cronapi as $function => $description) {
        $hooks[$function]['unsafe'] = isset($hooks[$function]['unsafe']) ? $hooks[$function]['unsafe'] : FALSE;
        $hooks[$function]['description'] = $description;
        $hooks[$function]['module'] = $module;
        $hooks[$function]['rules'] = ultimate_cron_get_default_rules($module, $function, ultimate_cron_easy_hooks_rule('cron'));
      }
    }
  }

  $configure = module_invoke_all('cronapi', 'configure');
  foreach ($hooks as $function => &$hook) {
    $hook['function'] = $function;
    $hook['fid'] = ultimate_cron_get_function_id($function);
    if (isset($configure[$function])) {
      $hook['configure'] = $configure[$function];
    }
  }
  // Remove ourselves from the list
  unset($hooks['ultimate_cron_cron']);
  unset($hooks['parallel_cron_cron']);

  // Allow other to manipulate the hook list
  drupal_alter('cron', $hooks);

  return $hooks;
}

/**
 * Get default rules for job.
 *
 * @param type $module
 * @param type $function
 * @return array
 */
function ultimate_cron_get_default_rules($module, $function, $default_rule) {
  $rules = module_invoke($module, 'cronapi', 'rule', $function);
  if (empty($rules)) {
    $rules = array($default_rule);
  }
  elseif (!is_array($rules)) {
    $rules = array($rules);
  }
  return $rules;
}

/**
 * Find modules that precedes Ultimate Cron and therefore cannot be handled
 * by Ultimate Cron.
 *
 * @return array
 *   List of modules.
 */
function ultimate_cron_uncronable_modules() {
  $modules = array();
  foreach (module_list() as $module) {
    if ($module === 'ultimate_cron') {
      break;
    }
    $modules[$module] = $module;
  }
  return $modules;
}

/**
 * Get hooks that are unsafe due to module weight.
 * @return type
 */
function ultimate_cron_unsafe_hooks() {
  $hooks = ultimate_cron_get_hooks();
  foreach ($hooks as $function => $hook) {
    if (empty($hook['unsafe'])) {
      unset($hooks[$function]);
    }
  }
  return $hooks;
}
/**
 * Get configuration for a function.
 *
 * @param $function
 * @return array
 *   Configuration for function
 */
function ultimate_cron_get_configuration($function) {
  $fid = ultimate_cron_get_function_id($function);
  if (!$fid) {
    return NULL;
  }

  $conf = db_query("SELECT fid, configuration FROM {ultimate_cron_configuration} WHERE fid = :fid", array(':fid' => $fid))->fetchObject();
  $conf = $conf && $conf->configuration ? unserialize($conf->configuration) : array();
  return $conf;
}

/**
 * Set configuration for a function.
 *
 * @param $function
 *   Function to set configuration for.
 * @param $conf
 *   Configuration data
 * @return boolean
 *   TRUE on success, FALSE on failure.
 */
function ultimate_cron_set_configuration($function, $conf) {
  $fid = ultimate_cron_get_function_id($function);
  if (!$fid) {
    return NULL;
  }

  return db_merge('ultimate_cron_configuration')
    ->key(array('fid' => $fid))
    ->fields(array(
      'configuration' => serialize($conf),
    ))
    ->execute();
}

/**
 * Get latest log line for a function.
 *
 * @param $function
 *   Function to get latest log line for,
 * @return object
 *   Log line.
 */
function ultimate_cron_get_log($fid) {
  $log = db_query_range("
    SELECT l.* FROM {ultimate_cron_log} l
    WHERE l.fid = :fid
    ORDER BY l.start DESC",
    0, 1, array(':fid' => $fid))
      ->fetchAssoc();
  return $log;
}

/**
 * Store watchdog error messages for later use.
 *
 * @staticvar string $log
 * @param $msg
 *   Message to record.
 * @param $reset
 *   Reset recorded message.
 * @return string
 *   Message recorded.
 */
function ultimate_cron_record_log($msg = NULL, $reset = FALSE) {
  static $log = '';
  if ($reset) {
    $log = '';
  }
  if ($msg) {
    $log .= "$msg\n";
  }
  return $log;
}

/**
 * Check if rule is valid.
 *
 * @param $rule
 *   rule to validate.
 * @return
 *   TRUE if valid, FALSE if not.
 */
function ultimate_cron_validate_rule($rule) {
  require_once(drupal_get_path('module', 'ultimate_cron') . '/CronRule.class.php');
  $cron = new CronRule($rule);
  if (!$cron->isValid()) {
    return FALSE;
  }
  else {
    return TRUE;
  }
}

/**
 * Check if rule is scheduled to run at a given time.
 *
 * @param $rules
 *   rules to validate.
 * @param $last_run
 *   last time the rule was run.
 * @param $now
 *   time of validation, set to NULL for now.
 * @param $catch_up
 *   run if we missed our time window?
 * @return boolean
 *   TRUE if rule is scheduled to run, FALSE if not.
 */
function ultimate_cron_should_run($rules, $last_run, $now = NULL, $catch_up = 0) {
  $now = is_null($now) ? time() : $now;
  require_once(drupal_get_path('module', 'ultimate_cron') . '/CronRule.class.php');
  foreach ($rules as $rule) {
    $cron = new CronRule($rule);
    $last_ran = $cron->getLastRan();
    if ($last_run < $last_ran && ($last_ran >= $now - $catch_up)) {
      return TRUE;
    }
  }
  return FALSE;
}

/**
 * Get a list of the "easy-hooks".
 *
 * @return array
 *    hooks (hook_name => hook_description).
 */
function ultimate_cron_easy_hooks() {
  return array(
    'cron'    => 'Default cron handler',
    'hourly'  => 'Hourly',
    'daily'   => 'Daily',
    'weekly'  => 'Weekly',
    'monthly' => 'Monthly',
    'yearly'  => 'Yearly'
  );
}

/**
 * Get rule(s) for easy hook(s)
 *
 * @param $hook
 *   Hook to get rule for (optional).
 * @return mixed
 *   Rule for $hook if specified, otherwise all rules for all easy hooks.
 */
function ultimate_cron_easy_hooks_rule($hook = NULL) {
  $rules = array(
    'cron'    => variable_get('ultimate_cron_rule', ULTIMATE_CRON_RULE),
    'hourly'  => ULTIMATE_CRON_HOURLY_RULE,
    'daily'   => ULTIMATE_CRON_DAILY_RULE,
    'weekly'  => ULTIMATE_CRON_WEEKLY_RULE,
    'monthly' => ULTIMATE_CRON_MONTHLY_RULE,
    'yearly'  => ULTIMATE_CRON_YEARLY_RULE,
  );
  return isset($rules[$hook]) ? $rules[$hook] : variable_get('ultimate_cron_rule', ULTIMATE_CRON_RULE);
}

/**
 * Get function ID based on function name. Will create the function in the
 * ultimate_cron_function table, if it doesn't exist.
 *
 * @param $function
 *   Function name
 * @return integer
 *   Function ID.
 */
function ultimate_cron_get_function_id($function, $fid = NULL) {
  static $ids = array();
  if (isset($fid)) {
    $ids[$function] = $fid;
  }
  if (isset($ids[$function])) {
    return $ids[$function];
  }
  $fid = db_query("SELECT fid FROM {ultimate_cron_function} WHERE `function` = :function ", array(':function' => $function))->fetchField();
  if (!$fid) {
    try {
      $fid = db_insert('ultimate_cron_function')
        ->fields(array(
          'function' => $function
        ))
        ->execute();
    }
    catch (Exception $e) {
      $fid = db_query("SELECT fid FROM {ultimate_cron_function} WHERE `function` = :function ", array(':function' => $function))->fetchField();
    }
  }
  $ids[$function] = $fid;
  return $fid;
}

/**
 * Reclaims position as the first module in the module list.
 */
function ultimate_cron_reclaim() {
  $weight = db_query("SELECT MIN(weight) FROM {system}")->fetchField();
  $weight --;
  db_update('system')
    ->fields(array(
      'weight' => $weight
    ))
    ->condition('name', 'ultimate_cron')
    ->execute();
  system_list_reset();
}

/**
 * Get module name
 * @param $module
 * @return string
 *   Name of module
 */
function ultimate_cron_module_name($module) {
  $file = drupal_get_path('module', $module) .'/'. $module .'.info';
  $info = drupal_parse_info_file($file);
  return $info['name'] ? $info['name'] : $module;
}

/**
 * Load all cronjob configurations and processes.
 *
 * @return array
 *   Array of cronjobs and their data.
 */
function _ultimate_cron_preload_cron_data() {
  $result = db_query("
SELECT f.fid, f.function, c.configuration, p.handle, p.service_host, p.start
FROM ultimate_cron_function f
LEFT JOIN ultimate_cron_configuration c ON f.fid = c.fid
LEFT JOIN background_process p ON p.handle = CONCAT('ultimate_cron:', f.fid)
");

  $data = array();
  while ($row = $result->fetchObject()) {
    $data[$row->function] = array(
      'configuration' => $row->configuration ? unserialize($row->configuration) : array(),
      'background_process' => empty($row->handle) ? NULL : (object)array(
        'handle' => $row->handle,
        'service_host' => $row->service_host,
        'start' => $row->start,
      ),
    );
  }
  return $data;
}
