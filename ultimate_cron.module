<?php
/**
 * @file
 *
 * @todo Add filter on overview page.
 * @todo Add log view (with graph).
 * @todo Make proper markup for overview page.
 * @todo Refactor drush stuff, too many intimate relations with Background Process
 * @todo Refactor Cron % offset stuff. Too mixed up and ungrokable code-wise and 'delta' is not consistent.
 *
 * hook_cron_alter(&$hooks)
 * hook_cron_schedule_alter(&$hooks)
 * hook_cron_pre_execute($name, $hook)
 * hook_cron_pre_execute_FUNCTION($hook)
 * hook_cron_post_execute($name, $hook)
 * hook_cron_post_execute_FUNCTION($hook)
 */

/**
 * Default rule.
 */
define('ULTIMATE_CRON_RULE',         '*/10+@ * * * *');

/**
 * Default max execution time for Ultimate Cron.
 */
define('ULTIMATE_CRON_MAX_EXECUTION_TIME', 86400);

/**
 * Default serviec group for Ultimate Cron.
 */
define('ULTIMATE_CRON_SERVICE_GROUP', 'default');

/**
 * Default catch up time for Ultimate Cron.
 */
define('ULTIMATE_CRON_CATCH_UP', 300);

/**
 * Default lease time for Ultimate Cron queues.
 */
define('ULTIMATE_CRON_QUEUE_LEASE_TIME', 30);

/**
 * Default clean up time for log entries (30 days).
 */
define('ULTIMATE_CRON_CLEANUP_LOG', 86400 * 30);

/**
 * Default setting for poorman.
 */
define('ULTIMATE_CRON_POORMAN', FALSE);

/**
 * Default queue polling latency.
 */
define('ULTIMATE_CRON_QUEUE_POLLING_LATENCY', '');

/**
 * Time in seconds to spend on launcing cron jobs.
 */
define('ULTIMATE_CRON_LAUNCH_WINDOW', 55);

// ---------- HOOKS ----------

module_load_include('nagios.inc', 'ultimate_cron');

/**
 * Implements hook_help().
 */
function ultimate_cron_help($path, $arg) {
  switch ($path) {
    case 'admin/help#ultimate_cron':
      // Return a line-break version of the module README
      return '<pre>' . file_get_contents(dirname(__FILE__) . '/README.txt') . '</pre>';
    case 'admin/build/cron':
      return '<p>' . t('Here you can see the crontab settings for each job available') . '</p>';
    case 'admin/build/cron/settings':
      return '<p>' . t('Here you can change the crontab settings for each job available') . '</p>';
  }
}

/**
 * Implements hook_menu().
 */
function ultimate_cron_menu() {
  $items = array();
  $items['admin/config/system/cron/settings'] = array(
    'title' => 'Settings',
    'description' => 'Cron settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('ultimate_cron_settings_form'),
    'access arguments' => array('administer ultimate cron'),
    'type' => MENU_LOCAL_TASK,
    'file' => 'ultimate_cron.admin.inc',
  );
  $items['admin/config/system/cron/settings/%'] = array(
    'title' => 'Settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('ultimate_cron_function_settings_form', 5),
    'access arguments' => array('administer ultimate cron'),
    'weight' => 0,
    'file' => 'ultimate_cron.admin.inc',
  );
  $items['admin/reports/cron'] = array(
    'title' => 'Cron logs',
    'description' => 'View logs for all cron jobs.',
    'page callback' => 'ultimate_cron_view_page',
    'access arguments' => array('administer ultimate cron'),
    'file' => 'ultimate_cron.admin.inc',
  );
  $items['admin/reports/cron/%'] = array(
    'title' => 'Cron log',
    'description' => 'View log for specific function.',
    'page callback' => 'ultimate_cron_function_log_page',
    'page arguments' => array(3),
    'access arguments' => array('administer ultimate cron'),
    'file' => 'ultimate_cron.admin.inc',
  );
  $items['admin/ultimate-cron/service/start/%'] = array(
    'type' => MENU_CALLBACK,
    'title' => 'Run cron job',
    'description' => 'Run cron job',
    'page callback' => 'ultimate_cron_service_start',
    'page arguments' => array(4),
    'access arguments' => array('administer ultimate cron'),
    'file' => 'ultimate_cron.admin.inc',
  );
  $items['admin/ultimate-cron/service/enable/%'] = array(
    'type' => MENU_CALLBACK,
    'title' => 'Enable cron job',
    'description' => 'Enable cron job',
    'page callback' => 'ultimate_cron_service_enable',
    'page arguments' => array(4, TRUE),
    'access arguments' => array('administer ultimate cron'),
    'file' => 'ultimate_cron.admin.inc',
  );
  $items['admin/ultimate-cron/service/disable/%'] = array(
    'type' => MENU_CALLBACK,
    'title' => 'Disable cron job',
    'description' => 'Disable cron job',
    'page callback' => 'ultimate_cron_service_enable',
    'page arguments' => array(4, FALSE),
    'access arguments' => array('administer ultimate cron'),
    'file' => 'ultimate_cron.admin.inc',
  );
  return $items;
}

/**
 * Implements hook_cron_queue_info().
 * Used for code injection in order to hijack cron runs.
 */
function ultimate_cron_cron_queue_info() {
  static $processed = FALSE;
  if (!$processed) {
    $processed = TRUE;
    if (basename($_SERVER['PHP_SELF']) == 'cron.php') {
      ultimate_cron_cron_run(FALSE);
      exit;
    }
  }
  return array();
}

/**
 * Implements hook_permission().
 */
function ultimate_cron_permission() {
  return array(
    'administer ultimate cron' => array(
      'title' => t('Administer Ultimate Cron'),
      'description' => t('Lets you configure everything in Ultimate Cron')
    )
  );
}

/**
 * Implements hook_cronapi().
 *
 * Exposes hook_cron() and cron queues to Ultimate Cron.
 */
function ultimate_cron_cronapi() {
  $items = array();

  $items['ultimate_cron_cleanup_log'] = array(
    'description' => t('Clean up old log entries'),
    'rules' => array('* * * * *'),
  );

  // Get default cron hooks
  foreach (module_implements('cron') as $module) {
    $file = drupal_get_path('module', $module) . '/' . $module . '.info';
    $info = drupal_parse_info_file($file);
    $items["{$module}_cron"] = array(
      'module' => $module,
      'description' => 'Default cron handler',
      'configure' => empty($info['configure']) ? NULL : $info['configure'],
    );

  }

  // Grab the defined cron queues.
  $queues = _ultimate_cron_get_queues();

  foreach ($queues as $queue_name => $info) {
    $items['queue_' . $queue_name] = array(
      'description' => t('Queue: %name', array('%name' => $queue_name)),
      'callback' => 'ultimate_cron_queue_cron',
      'arguments' => array($queue_name),
      'rules' => array('* * * * *'),
      'queue lease time' => variable_get('ultimate_cron_queue_lease_time', ULTIMATE_CRON_QUEUE_LEASE_TIME),
      'queue polling latency' => variable_get('ultimate_cron_queue_polling_latency', ULTIMATE_CRON_QUEUE_POLLING_LATENCY),
    );
  }
  return $items;
}

/**
 * Implements hook_watchdog().
 */
function ultimate_cron_watchdog($log = array()) {
  $record = &drupal_static('ultimate_cron_record', FALSE);
  if ($record) {
    $log['variables'] = is_array($log['variables']) ? $log['variables'] : array();
    ultimate_cron_record_log(t($log['message'], $log['variables']), $log['severity']);
  }
}

/**
 * Implements hook_init().
 */
function ultimate_cron_init() {
  // No need for hocus pocus and poorman until site is installed.
  if (variable_get('install_task') != 'done') {
    return;
  }

  $name = 'cron_last';
  if ($value = db_query("SELECT value FROM {variable} WHERE name = :name", array(':name' => $name))->fetchField()) {
    $value = unserialize($value);
  }
  global $conf;
  $conf['cron_last'] = $value;

  ultimate_cron_trigger_poorman();
}

/**
 * Implements hook_background_process_shutdown().
 *
 * Shutdown handler for cronjobs.
 */
function ultimate_cron_background_process_shutdown($process, $msg = NULL) {
  $args = func_get_args();
  $name = preg_replace('/^uc:/', '', $process->getHandle());
  if (!empty($name) && $name != $process->getHandle()) {
    // Record end time
    $end = microtime(TRUE);

    if (!$msg) {
      // Get watchdog messages
      $log = ultimate_cron_record_log();
      $msg = $log['msg'];

      // Get drupal messages
      $messages = drupal_get_messages();
      $msg .= empty($messages['status']) ? '' : join("\n", $messages['status']) . "\n";
      $msg .= empty($messages['warning']) ? '' : join("\n", $messages['warning']) . "\n";
      $msg .= empty($messages['error']) ? '' : join("\n", $messages['error']) . "\n";

      // Get error messages
      $error = error_get_last();
      if ($error) {
        $msg .= $error['message'] . ' (line ' . $error['line'] . ' of ' . $error['file'] . ').' . "\n";
      }
    }

    // log results here ...
    $object = (object)array(
      'name' => $name,
      'start_time' => $process->getStartTime(),
      'end_time' => $end,
      'severity' => $log['severity'],
      'msg' => trim($msg),
    );
    drupal_write_record('ultimate_cron_log', $object);
  }
}


// ---------- FIXUPS FOR CORE  ----------

/**
 * Implements hook_menu_alter().
 *
 * Steal the run-cron, so when you "run cron manually" from the status-reports
 * page the ultimate_cron cron handler is run.
 */
function ultimate_cron_menu_alter(&$items) {
  $items['admin/config/system/cron'] = array(
    'title' => 'Cron',
    'description' => 'View and manage cron table',
    'page callback' => 'ultimate_cron_view_page',
    'access arguments' => array('administer ultimate cron'),
    'module' => 'ultimate_cron',
    'file' => 'ultimate_cron.admin.inc',
  );
  $items['admin/config/system/cron/overview'] = array(
    'title' => 'List',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );
  $steal = &$items['admin/reports/status/run-cron'];
  $steal['page callback'] = 'ultimate_cron_run_cron';
  $steal['page arguments'] = array();
  $steal['module'] = 'ultimate_cron';
  $steal['file'] = 'ultimate_cron.admin.inc';
}

/**
 * Implements hook_cron_alter().
 * Add better description to core modules.
 */
function ultimate_cron_cron_alter(&$hooks) {
  $update['dblog_cron']['description'] = t('Remove expired log messages and flood control events');
  $update['field_cron']['description'] = t('Purges deleted Field API data');
  $update['filter_cron']['description'] = t('Expire outdated filter cache entries');
  $update['node_cron']['description'] = t('Mark old nodes as read');
  $update['search_cron']['description'] = t('Update indexes');
  $update['system_cron']['description'] = t('Cleanup (batch, flood, temp-files, etc.)');
  $update['aggregator_cron']['description'] = t('Refresh feeds');
  $update['openid_cron']['description'] = t('Remove expired nonces from the database');
  $update['ping_cron']['description'] = t('Notify remote sites');
  $update['poll_cron']['description'] = t('Close expired polls');
  $update['statistics_cron']['description'] = t('Reset counts and clean up');
  $update['trigger_cron']['description'] = t('Run actions for cron triggers');
  $update['tracker_cron']['description'] = t('Update tracker index');
  $update['update_cron']['description'] = t('Check system for updates');
  $update['ultimate_cron_cleanup_log']['configure'] = 'admin/config/system/cron/settings';
  $update['dblog_cron']['configure'] = 'admin/config/development/logging';

  foreach ($update as $name => $data) {
    if (isset($hooks[$name])) {
      foreach ($data as $key => $value) {
        $hooks[$name][$key] = $value;
      }
    }
  }
}

// ---------- CALLBACK FUNCTIONS ----------

/**
 * The cron handler takes over the normal Drupal cron handler
 * and runs the normal hook_cron() plus the hook_cronapi().
 *
 * @param boolean $return
 *   return to caller if TRUE, otherwise exit().
 */
function ultimate_cron_cron_run($return = FALSE) {
  if (variable_get('install_task', FALSE) != 'done') {
    return;
  }

  // If run from core cron through CLI then don't do anything (drush core-cron)
  if (!$return && drupal_is_cli()) {
    return;
  }

  // Acquire lock
  if (!lock_acquire('cron', 240.0)) {
    drupal_set_message(t('Ultimate Cron launcher already running'), 'error');
    return;
  }

  // Get list of cron hooks.
  $hooks = ultimate_cron_get_hooks();

  // Get schedule.
  $schedule = ultimate_cron_get_schedule($hooks);

  drupal_set_message(t('%jobs jobs scheduled for launch', array('%jobs' => count($schedule))));

  // Start the jobs. Keep launching jobs until X seconds into the request.
  set_time_limit(120);
  $time = time();
  $expire = $time + variable_get('ultimate_cron_launch_window', ULTIMATE_CRON_LAUNCH_WINDOW);
  $running = array();
  $launched = 0;

  // Try to launch jobs within the given time frame
  while (!empty($schedule) && time() < $expire) {
    $running_processes = db_select('background_process', 'bp', array('target' => 'background_process'))
                          ->fields('bp', array('handle'))
                          ->condition('bp.handle', 'uc:%', 'LIKE')
                          ->countQuery()
                          ->execute()
                          ->fetchField();

    // Launch jobs.
    reset($schedule);
    while ((list($name, $hook) = each($schedule)) && time() < $expire) {
      $process = ultimate_cron_run_hook($hook);
      if (!$process) {
        continue;
      }

      $running[$process->handle] = $process;
      unset($schedule[$name]);
      $launched++;
      $running_processes++;
    }

    // Jobs running ... check for start
    if ($running) {
      $pids = db_select('background_process', 'bp', array('target' => 'background_process'))
                ->fields('bp', array('pid', 'handle'))
                ->condition('bp.handle', array_keys($running), 'IN')
                ->condition('bp.exec_status', BACKGROUND_PROCESS_STATUS_RUNNING)
                ->execute()
                ->fetchAllKeyed(0, 1);
      foreach ($pids as $pid => $handle) {
        unset($running[$handle]);
      }
    }
    sleep(1);
  }

  // Close all jobs left
  if ($running) {
    foreach (array_keys($running) as $handle) {
      #fclose($running[$handle]);
      unset($running[$handle]);
    }
  }

  // Update drupals cron timestamp, but don't clear the cache for all variables!
  $name = 'cron_last';
  $value = time();
  global $conf;
  db_merge('variable')->key(array('name' => $name))->fields(array('value' => serialize($value)))->execute();
  $conf[$name] = $value;

  drupal_set_message(t('%jobs jobs launched', array('%jobs' => $launched)));
  if (count($schedule)) {
    drupal_set_message(t('%jobs jobs failed to launch within %seconds seconds', array(
      '%jobs' => count($schedule),
      '%seconds' => variable_get('ultimate_cron_launch_window', ULTIMATE_CRON_LAUNCH_WINDOW)
    )), empty($schedule) ? 'status' : 'error');
    watchdog('ultimate_cron', '%jobs jobs failed to launch within %seconds seconds', array(
      '%jobs' => count($schedule),
      '%seconds' => variable_get('ultimate_cron_launch_window', ULTIMATE_CRON_LAUNCH_WINDOW)
    ), WATCHDOG_WARNING);
  }

  // Release the lock
  lock_release('cron');

  // And we're done ...
  if ($return) {
    return empty($schedule);
  }
  else {
    exit;
  }
}

/**
 * Process a cron queue.
 */
function ultimate_cron_queue_cron($hook, $queue_name) {
  $polling_latency = $hook['queue polling latency'];
  $queues = _ultimate_cron_get_queues();
  $info = $queues[$queue_name];

  $function = $info['worker callback'];
  $end = time() + (isset($info['time']) ? $info['time'] : 15);
  $queue = DrupalQueue::get($queue_name);
  $items = 0;
  while (time() < $end) {
    $item = $queue->claimItem($hook['queue lease time']);
    if (!$item) {
      if (is_numeric($polling_latency)) {
        usleep($polling_latency * 1000);
        continue;
      }
      else {
        break;
      }
    }
    $function($item->data);
    $queue->deleteItem($item);
    $items++;
  }
  drupal_set_message(t('Processed @items items', array('@items' => $items)));

  if (is_numeric($polling_latency)) {
    // Reload settings
    $keepalive = FALSE;
    $hooks = ultimate_cron_get_hooks();
    if (!empty($hooks[$hook['name']])) {
      $hook = $hooks[$hook['name']];
      $keepalive = ultimate_cron_hook_should_run($hook);
    }
    $process = BackgroundProcess::currentProcess();
    $process->keepAlive($keepalive);
  }
  return;
}

// ---------- HELPER FUNCTIONS ----------

/**
 * Get cron queues and static cache them
 */
function _ultimate_cron_get_queues() {
  static $queues = NULL;
  if (!isset($queues)) {
    $queues = module_invoke_all('cron_queue_info');
    drupal_alter('cron_queue_info', $queues);
  }
  return $queues;
}

function ultimate_cron_module_name($module) {
  $file = drupal_get_path('module', $module) . '/' . $module . '.info';
  $info = drupal_parse_info_file($file);
  return $info['name'] ? $info['name'] : $module;
}



/**
 * Clean up log entries.
 */
function ultimate_cron_cleanup_log() {
  watchdog('ultimate_cron', 'testing1 ...', array(), WATCHDOG_INFO);
  #watchdog('ultimate_cron', 'testing2 ...', array(), WATCHDOG_CRITICAL);
  do {
    $lids = db_select('ultimate_cron_log', 'l')
              ->fields('l', array('lid'))
              ->condition('start_time', time() - variable_get('ultimate_cron_cleanup_log', ULTIMATE_CRON_CLEANUP_LOG), '<')
              ->range(0, 1000)
              ->execute()
              ->fetchAllKeyed(0, 0);
    if (!empty($lids)) {
      db_delete('ultimate_cron_log')
        ->condition('lid', $lids, 'IN')
        ->execute();
    }
  } while (!empty($lids));
}

/**
 * Run a cron hook.
 * Launches the cron job in a background process
 *
 * @param $name
 * @param $hook
 * @return mixed
 *   Connections file handle on success.
 */
function ultimate_cron_run_hook($hook) {
  // Run the job in background
  $result = NULL;
  $handle = "uc:" . $hook['name'];
  try {
    $process = BackgroundProcess::lock($handle);

    // Determine service group
    if (!empty($hook['settings']['service_group'])) {
      $process->setServiceGroup($hook['settings']['service_group']);
    }
    $process->setCallback('_ultimate_cron_run_hook', array($hook));
    $process->call();
    return $process;
  }
  catch (Exception $e) {
    return FALSE;
  }
}

function ultimate_cron_run_hook_cli($hook) {
  // Run the job in background
  $result = NULL;
  $handle = "uc:" . $hook['name'];
  $process = BackgroundProcess::lock($handle);

  // Determine service group
  if (!empty($hook['settings']['service_group'])) {
    $process->setServiceGroup($hook['settings']['service_group']);
  }
  $hook['timestamp'] = time();
  $process->setCallback('_ultimate_cron_run_hook', array($hook));
  $process->runNow();
  return $process;
}

/**
 * This is the function that is launched into a background process.
 * It runs the cron job and does housekeeping, pre/post execute hooks, etc.
 *
 * @param $hook
 *   Hook definition
 * @return boolean
 *   TRUE on success, FALSE on failure.
 */
function _ultimate_cron_run_hook($hook) {
  set_time_limit(variable_get('ultimate_cron_max_execution_time', ULTIMATE_CRON_MAX_EXECUTION_TIME));
  drupal_save_session(FALSE);

  // Load current process
  $process = BackgroundProcess::currentProcess();

  $log = &drupal_static('ultimate_cron_record_log', array('msg' => '', 'severity' => -1));
  $log = array('msg' => '', 'severity' => -1);
  $record = &drupal_static('ultimate_cron_record', FALSE);
  $record = TRUE;

/*
  $time = time();
  if (empty($hook['skip_catch_up']) && !ultimate_cron_hook_should_run($hook)) {
    // Hook started too late!
    watchdog('ultimate_cron', '%function skipped. Invoked at %invoke, but did not start until %start', array(
      '%function' => $name,
      '%invoke' => format_date($hook['timestamp'], 'custom', 'Y-m-d H:i:s'),
      '%start' => format_date($time, 'custom', 'Y-m-d H:i:s'),
    ), WATCHDOG_ERROR);
    #ultimate_cron_background_process_shutdown($process, NULL);
    return FALSE;
  }
*/
  // Let other modules do stuff before execution, if they need to.
  module_invoke_all('cron_pre_execute', $hook);
  module_invoke_all('cron_pre_execute_' . $hook);

  if (!empty($item['file'])) {
    require_once($item['file path'] . DIRECTORY_SEPARATOR . $item['file']);
  }

  if (is_callable($hook['callback'])) {
    $args = array_merge(array($hook), $hook['arguments']);
    call_user_func_array($hook['callback'], $args);
  }
  else {
    // WTF?
  }

  // Let other modules do stuff before execution, if they need to.
  module_invoke_all('cron_post_execute', $hook);
  module_invoke_all('cron_post_execute_' . $hook);

  return TRUE;
}

/**
 * Get a list of functions that should be run now.
 *
 * @param $hooks
 *   Array of cron hooks to check.
 * @return array
 *   Functions to run now.
 */
function ultimate_cron_get_schedule($hooks) {
  // Create list of scheduled functions
  $schedule = array();
  foreach ($hooks as $name => &$hook) {
    // Store last run in hook for sorting purposes
    $log = ultimate_cron_get_last_log_entry($name);
    $last_run = isset($log['start']) ? $log['start'] : 0;
    $hook['last_run'] = $last_run;

    if (ultimate_cron_hook_should_run($hook)) {
      $schedule[$name] = $hook;
    }
  }

  // Sort by last run time
  uasort($schedule, '_ultimate_cron_sort_schedule');

  // Allow other to manipulate the schedule
  drupal_alter('cron_schedule', $schedule);

  return $schedule;
}

/**
 * Check if a hook should be run now.
 *
 * @param array $hook
 * @return boolean
 */
function ultimate_cron_hook_should_run($hook) {
  // Is it enabled?
  if (empty($hook['enabled'])) {
    return FALSE;
  }

  $log = ultimate_cron_get_last_log_entry($hook['name']);
  $last_run = isset($log['start']) ? $log['start'] : 0;

  return ultimate_cron_should_run($hook['rules'], $last_run, time(), $hook['catch up'], $hook['original weight']);
}

/**
 * Sort callback for ordering schedule.
 *
 * @param type $a
 * @param type $b
 * @return type
 */
function _ultimate_cron_sort_schedule($a, $b) {
  return $a['last_run'] == $b['last_run'] ? 0 : ($a['last_run'] < $b['last_run'] ? -1 : 1);
}

/**
 * Get cron hooks available.
 *
 * @return array
 *   List of modules.
 */
function ultimate_cron_get_hooks() {
  static $hooks = NULL;
  if (isset($hooks)) {
    return $hooks;
  }
  $hooks = array();
  $weight = 0;

  $settings = ultimate_cron_load_all();

  $query = db_select('background_process', 'b', array('target' => 'background_process'))
    ->fields('b')
    ->condition('handle', 'uc:%', 'LIKE');
  $processes = $query->execute()->fetchAllAssoc('handle', PDO::FETCH_OBJ);

  // Generate list of hooks
  $modules = module_list();
  foreach ($modules as $module) {
    // Get cronapi data
    $cron = module_invoke($module, 'cronapi', 'list');

    // Cleanup data
    if ($cron) {
      foreach ($cron as $name => &$item) {
        if (!is_array($item)) {
          // Support old style cronapi :-(
          $desc = $item;

          $rules = module_invoke($module, 'cronapi', 'rule', $name);
          $rules = is_array($rules) ? $rules : ($rules ? array($rules) : array());

          $legacy_settings = module_invoke($module, 'cronapi', 'settings', $name);
          $legacy_settings = $legacy_settings ? $legacy_settings : array();
          if (empty($legacy_settings['rules']) && $rules) $legacy_settings['rules'] = $rules;

          $item = empty($settings[$name]) ? array() : $settings[$name]->settings;
          $item += $legacy_settings;
          $item += array(
            'description' => $desc,
            'configure' => module_invoke($module, 'cronapi', 'configure', $name),
          );
        }
        else {
          $item = empty($settings[$name]) ? $item : $settings[$name]->settings + $item;
        }
        $item += array(
          'description' => $name,
          'module' => $module,
          'file path' => drupal_get_path('module', $module),
          'rules' => array(variable_get('ultimate_cron_rule', ULTIMATE_CRON_RULE)),
          'original weight' => $weight++,
          'weight' => 0,
          'arguments' => array(),
          'callback' => $name,
          'catch up' => variable_get('ultimate_cron_catch_up', ULTIMATE_CRON_CATCH_UP),
          'background_process' => empty($processes['uc:' . $name]) ? NULL : BackgroundProcess::create($processes['uc:' . $name]),
          'service group' => variable_get('ultimate_cron_service_group', ULTIMATE_CRON_SERVICE_GROUP),
          'enabled' => TRUE,
        );
        $item['name'] = $name;
      }
      $hooks += $cron;
    }
  }

  // Allow other to manipulate the hook list
  drupal_alter('cron', $hooks);

  return $hooks;
}

/**
 * Store watchdog error messages for later use.
 *
 * @staticvar string $log
 * @param $msg
 *   Message to record.
 * @param $reset
 *   Reset recorded message.
 * @return string
 *   Message recorded.
 */
function ultimate_cron_record_log($msg = NULL, $severity = -1) {
  $log = &drupal_static('ultimate_cron_record_log', array('msg' => '', 'severity' => -1));
  if ($msg) {
    $log['msg'] .= "$msg\n";
  }
  if ($severity > 0) {
    if ($log['severity'] < 0 || $severity <= $log['severity']) {
      $log['severity'] = $severity;
    }
  }
  return $log;
}

// ---------- CRON RULE FUNCTIONS ----------

/**
 * Check if rule is valid.
 *
 * @param $rule
 *   rule to validate.
 * @return
 *   TRUE if valid, FALSE if not.
 */
function ultimate_cron_validate_rule($rule) {
  require_once 'CronRule.class.php';
  $cron = new CronRule($rule);
  if (!$cron->isValid()) {
    return FALSE;
  }
  else {
    return TRUE;
  }
}

/**
 * Check if rule is scheduled to run at a given time.
 *
 * @param $rules
 *   rules to validate.
 * @param $last_run
 *   last time the rule was run.
 * @param $now
 *   time of validation, set to NULL for now.
 * @param $catch_up
 *   run if we missed our time window?
 * @return boolean
 *   TRUE if rule is scheduled to run, FALSE if not.
 */
function ultimate_cron_should_run($rules, $last_run, $now = NULL, $catch_up = 0, $offset = 0) {
  $now = is_null($now) ? time() : $now;
  require_once 'CronRule.class.php';
  $cron = new CronRule();
  foreach ($rules as $rule) {
    $cron->rule = $rule;
    $cron->offset = $offset;
    $last_ran = $cron->getLastRan($now);
    if ($last_ran > $last_run && $last_ran >= $now - $catch_up) {
      return TRUE;
    }
  }
  return FALSE;
}

// ---------- CRUD/DB FUNCTIONS ----------

/**
 * Load settings for a cron job
 *
 * @param $name
 *
 * @return object
 *   Settings
 */
function ultimate_cron_load($name) {
  if (module_exists('ctools')) {
    ctools_include('export');
    $settings = ctools_export_crud_load('ultimate_cron', $name);
    if (!empty($settings->settings)) {
      $settings->settings = (array) $settings->settings;
    }
  }
  else {
    $settings = db_select('ultimate_cron', 'uc')
                  ->fields('uc')
                  ->condition('uc.name', $name)
                  ->execute()
                  ->fetchObject();
    if (!empty($settings->settings)) {
      $settings->settings = (array) unserialize($settings->settings);
    }
  }
  return $settings;
}

/**
 * CRUD save. Also used for ctools integration.
 * @param object $object
 *   object to be saved ->name containing unique machine name.
 * @return boolean
 *   result of query.
 */
function ultimate_cron_crud_save($object) {
  return db_merge('ultimate_cron')
    ->key(array('name' => $object->name))
    ->fields(array(
      'settings' => serialize($object->settings),
    ))
    ->execute();
}

/**
 * Save
 *
 * @param object $object
 *   object to be saved ->name containing unique machine name.
 * @return boolean
 *   result of query.
 */
function ultimate_cron_save($object) {
  if (module_exists('ctools')) {
    ctools_include('export');
    $settings = ctools_export_crud_new('ultimate_cron');
    $settings->name = $object->name;
    $settings->settings = $object->settings;
    return ctools_export_crud_save('ultimate_cron', $settings);
  }
  else {
    return ultimate_cron_crud_save($object);
  }
}

/**
 * Load all cronjob settings and processes.
 *
 * @return array
 *   Array of cronjobs and their data.
 */
function ultimate_cron_load_all() {
  if (module_exists('ctools')) {
    ctools_include('export');
    $settings = ctools_export_crud_load_all('ultimate_cron');
    #foreach ($settings as $info) {
      #$info->settings = !empty($info->settings) ? (array) unserialize($info->settings) : array();
    #}
  }
  else {
    $settings = db_select('ultimate_cron', 'u')
      ->fields('u', array('name', 'settings'))
      ->execute()
      ->fetchAllKeyed('name', PDO::FETCH_OBJ);
    foreach ($settings as $info) {
      $info->settings = $info->settings ? (array) unserialize($info->settings) : array();
    }
  }
  return $settings;
}

/**
 * Get latest log line for a function.
 *
 * @param $name
 *   Function to get latest log line for,
 * @return object
 *   Log line.
 */
function ultimate_cron_get_last_log_entry($name) {
  static $logs = array();
  if (isset($logs[$name])) {
    return $logs[$name];
  }

  $log = db_select('ultimate_cron_log', 'l')
           ->fields('l')
           ->condition('l.name', $name)
           ->orderBy('l.start_time', 'DESC')
           ->range(0, 1)
           ->execute()
           ->fetchAssoc();
  $logs[$name] = $log;
  return $log;
}

// ---------- POORMAN FUNCTIONS ----------

/**
 * Launch poorman cron if it's time to do so.
 */
function ultimate_cron_trigger_poorman() {
  // Launch poormans cron if applicable
  if (variable_get('ultimate_cron_poorman', ULTIMATE_CRON_POORMAN)) {
    $last = variable_get('cron_last', 0);
    $last = floor($last / 60) * 60;
    $time = time();
    $time = floor($time / 60) * 60;
    // Don't attempt, if already run within last minute
    if ($last < $time) {
      ultimate_cron_launch_poorman();
    }
  }
}

/**
 * Launch the poormans cron background process.
 */
function ultimate_cron_launch_poorman() {
  $handle = 'ultimate_cron_poorman';
  if ($process = BackgroundProcess::loadByHandle($handle)) {
    if ($process->getStartTime() + 120 < time()) {
      $process->shutdown('Stale poorman launcher ... shutting it down');
      $process = NULL;
    }
  }
  if (!$process) {
    $process = BackgroundProcess::lock($handle)
                 ->setServiceHost('ultimate_cron_poorman')
                 ->setCallback('_ultimate_cron_poorman')
                 ->keepAlive()
                 ->call();
  }
}

/**
 * The actual poorman function
 * @return type
 */
function _ultimate_cron_poorman() {
  if (!variable_get('ultimate_cron_poorman', ULTIMATE_CRON_POORMAN)) {
    return;
  }

  // Restart when done
  #background_process_keepalive();

  // Derive current minute
  $time = time();
  $time = floor($time / 60) * 60;

  // Run the cron
  ultimate_cron_cron_run(TRUE);

  // Wait until end of "current" minute
  $wait = $time + 60 - time();
  if ($wait > 0 && $wait <= 60) {
    sleep($wait);
  }
}
