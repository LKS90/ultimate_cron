<?php
/**
 * @file
 * Ultimate Cron. Extend cron functionality in Drupal.
 *
 * @todo Add log view (with graph).
 * @todo Refactor Cron % offset stuff. Too mixed up and ungrokable code-wise and 'delta' is not consistent.
 *
 * hook_cron_alter(&$hooks)
 * hook_cron_schedule_alter(&$hooks)
 * hook_cron_pre_execute($name, $hook)
 * hook_cron_pre_execute_FUNCTION($hook)
 * hook_cron_post_execute($name, $hook)
 * hook_cron_post_execute_FUNCTION($hook)
 */


// module_load_include('nagios.inc', 'ultimate_cron');

module_load_include('lock.inc', 'ultimate_cron');
module_load_include('job.inc', 'ultimate_cron');
module_load_include('plugin.inc', 'ultimate_cron');

/**
 * Memory exhaust protection.
 * To reduce the risk of shutdown handlers failing, we reserve 2MiB of memory
 */
if (!function_exists('_out_of_memory_protection')) {
  $GLOBALS['__RESERVED_MEMORY'] = str_repeat('0', 1024 * 1024 * 2);

  function _out_of_memory_protection() {
    unset($GLOBALS['__RESERVED_MEMORY']);
  }

  // The minor overhead in _drupal_shutdown_function() can mean the
  // difference between life and death for our shutdown handlers in
  // a memory exhaust situation. We want our shutdown handler to be
  // called as early as possible. If no callbacks have been registrered
  // yet, we use PHPs built-in register_shutdown_function() otherwise
  // we ensure, that we are the first in the list of Drupals registered
  // shutdown functions.
  $callbacks = &drupal_register_shutdown_function();
  if (empty($callbacks)) {
    register_shutdown_function('_out_of_memory_protection');
  }
  else {
    array_unshift($callbacks, array('callback' => '_out_of_memory_protection', 'arguments' => array()));
    // Reset internal array pointer just in case ...
    reset($callbacks);
  }
}

/**
 * Output buffer callback for poormans cron early page flush.
 */
function _ultimate_cron_poormans_page_flush($content) {
  if (!empty($GLOBALS['poorman_active'])) {
    $size = strlen($content);
    header("Content-Length: $size");
    header("Connection: close");
  }
  return $content;
}
if (!drupal_is_cli() && $_SERVER['REQUEST_METHOD'] == 'GET') {
  ob_start('_ultimate_cron_poormans_page_flush');
}

// ---------- CTOOLS INTEGRATION ----------

/**
 * Implements of hook_ctools_plugin_api().
 */
function ultimate_cron_ctools_plugin_api($module, $api) {
  if ($module == 'ultimate_cron' && $api == 'plugins') {
    return array('version' => 3);
  }
  if ($module == 'ultimate_cron' && $api == 'ultimate_cron') {
    return array('version' => 3);
  }
}

/**
 * Implement of hook_ctools_plugin_directory().
 */
function ultimate_cron_ctools_plugin_directory($module, $type) {
  // Safety: go away if CTools is not at an appropriate version.
  if (!module_invoke('ctools', 'api_version', '1.7')) {
    return;
  }
  $supported = array(
    'ctools' => array(
      'export_ui' => 'export_ui',
    ),
    'ultimate_cron' => array(
      'settings' => 'settings',
      'scheduler' => 'scheduler',
      'launcher' => 'launcher',
      'logger' => 'logger',
    ),
  );

  if (isset($supported[$module][$type])) {
    return "plugins/" . $supported[$module][$type];
  }
}

/**
 * Implements hook_ctools_plugin_type().
 */
function ultimate_cron_ctools_plugin_type() {
  return array(
    'settings' => array(
      'use hooks' => FALSE,
      'defaults' => array(
        'static' => array(
          'default plugin' => '',
          'title singular' => t('settings'),
          'title plural' => t('settings'),
          'title singular proper' => t('Settings'),
          'title plural proper' => t('Settings'),
          'class' => 'UltimateCronSettings',
          'multiple' => TRUE,
        ),
      ),
    ),
    'scheduler' => array(
      'use hooks' => FALSE,
      'defaults' => array(
        'static' => array(
          'default plugin' => 'simple',
          'title singular' => t('scheduler'),
          'title plural' => t('schedulers'),
          'title singular proper' => t('Scheduler'),
          'title plural proper' => t('Schedulers'),
          'class' => 'UltimateCronScheduler',
        ),
      ),
    ),
    'launcher' => array(
      'use hooks' => FALSE,
      'defaults' => array(
        'static' => array(
          'default plugin' => 'serial',
          'title singular' => t('launcher'),
          'title plural' => t('launchers'),
          'title singular proper' => t('Launcher'),
          'title plural proper' => t('Launchers'),
          'class' => 'UltimateCronLauncher',
        ),
      ),
    ),
    'logger' => array(
      'use hooks' => FALSE,
      'defaults' => array(
        'static' => array(
          'default plugin' => 'database',
          'title singular' => t('logger'),
          'title plural' => t('loggers'),
          'title singular proper' => t('Logger'),
          'title plural proper' => t('Loggers'),
          'class' => 'UltimateCronLogger',
        ),
      ),
    ),
  );
}

function ultimate_cron_ctools_plugin_instance($name, $plugin) {
  $class = ctools_plugin_get_class($plugin, 'handler');
  return $class ? new $class($name, $plugin) : FALSE;
}

/**
 * Load callback for plugins.
 */
function ultimate_cron_plugin_load($plugin_type, $name) {
  $plugins = ultimate_cron_plugin_load_all($plugin_type);
  return $plugins[$name];
}

/**
 * Load all callback for launchers.
 */
function ultimate_cron_plugin_load_all($plugin_type) {
  ctools_include('plugins');
  $plugin_infos = ctools_get_plugins('ultimate_cron', $plugin_type);
  $plugins = array();
  foreach ($plugin_infos as $name => $plugin) {
    if ($object = ultimate_cron_ctools_plugin_instance($name, $plugin)) {
      $plugins[$name] = $object;
    }
  }
  return $plugins;
}

/**
 * Load callback for cron jobs.
 *
 * @param string $name
 *   Name of job.
 *
 * @return object
 *   Job object.
 */
function ultimate_cron_job_load_export_ui($name) {
  ctools_include('export');
  $result = ctools_export_load_object('ultimate_cron_job', 'names', array($name));
  if (isset($result[$name])) {
    $result[$name]->settings = !empty($result[$name]->settings) ? $result[$name]->settings : array();
    return $result[$name];
  }
  return FALSE;
}

/**
 * Load all callback for cron jobs.
 *
 * @return array
 *   Job objects.
 */
function ultimate_cron_job_load_all_export_ui($reset = FALSE) {
  ctools_include('export');
  if ($reset) {
    ctools_export_load_object_reset('ultimate_cron_job');
  }
  $results = ctools_export_load_object('ultimate_cron_job');
  foreach ($results as $result) {
    $result->settings = !empty($result->settings) ? $result->settings : array();
  }
  return $results;
}

function ultimate_cron_job_load($name) {
  $jobs = ultimate_cron_job_load_all();
  return $jobs[$name];
}

function ultimate_cron_job_load_all($reset = FALSE) {
  $jobs = ultimate_cron_job_load_all_export_ui($reset);
  $schema = ctools_export_get_schema('ultimate_cron_job');
  $export = $schema['export'];
  $status = variable_get($export['status'], array());

  $hooks = array();
  foreach (ultimate_cron_get_hooks($reset) as $name => $hook) {
    if (!isset($jobs[$name])) {
      $jobs[$name] = ctools_export_crud_new('ultimate_cron_job');
      $jobs[$name]->name = $name;
      $jobs[$name]->title = $hook['title'];
      $jobs[$name]->description = $hook['description'];
      $jobs[$name]->table = 'ultimate_cron_job';
      $jobs[$name]->export_type = EXPORT_IN_CODE;
      $jobs[$name]->{$export['export type string']} = t('Default');
      if (isset($status[$jobs[$name]->{$export['key']}])) {
        $jobs[$name]->disabled = $status[$jobs[$name]->{$export['key']}];
      }
      if (!isset($jobs[$name]->disabled)) {
        $jobs[$name]->disabled = !$hook['enabled'];
      }
    }
    else {
      $jobs[$name]->{$export['export type string']} = t('Overridden');
      $jobs[$name]->export_type = EXPORT_IN_CODE | EXPORT_IN_DATABASE;
    }

    $jobs[$name]->hook = $hook;
  }

  return $jobs;
}


// ---------- HOOKS ----------

/**
 * Implements hook_exit().
 */
function ultimate_cron_exit($dest = NULL) {
  // We're picky about when we run poormans cron, because
  // we want to flush the output buffer.
  if (!drupal_is_cli() && $_SERVER['REQUEST_METHOD'] == 'GET') {
    // Register our own Poormans Cron handler.
    $callbacks = &drupal_register_shutdown_function();
    array_unshift($callbacks, array('callback' => 'ultimate_cron_poorman', 'arguments' => array()));
    // Reset internal array pointer just in case ...
    reset($callbacks);
  }
}

function ultimate_cron_poorman() {
  $settings = ultimate_cron_plugin_load('settings', 'general')->getDefaultSettings();
  $cron_last = variable_get('cron_last', 0);
  if ($settings['poorman_interval'] && ($cron_last < time() - $settings['poorman_interval'])) {
    // Thundering herd protection should be done in the launcher.

    if ($settings['poorman_page_flush']) {
      ignore_user_abort();
      $GLOBALS['poorman_active'] = TRUE;
      while (ob_get_level() > 0) {
        ob_end_flush();
      }
      flush();

      // FastCGI may need another way of letting the client know, that
      // we're done with it.
      if (function_exists('fastcgi_finish_request')) {
        fastcgi_finish_request();
      }
    }

    ultimate_cron_run_scheduled(FALSE);
  }
}

/**
 * Implements hook_help().
 */
function ultimate_cron_help($path, $arg) {
  switch ($path) {
    case 'admin/help#ultimate_cron':
      // Return a line-break version of the module README.
      return '<pre>' . file_get_contents(dirname(__FILE__) . '/README.txt') . '</pre>';

    case 'admin/build/cron':
      return '<p>' . t('Here you can see the crontab settings for each job available') . '</p>';

    case 'admin/build/cron/settings':
      return '<p>' . t('Here you can change the crontab settings for each job available') . '</p>';
  }
}

/**
 * Implements hook_menu().
 */
function ultimate_cron_menu() {
  $items = array();

  $items['admin/config/system/cron/settings'] = array(
    'title' => 'Settings',
    'description' => 'Cron settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('ultimate_cron_settings_form'),
    'access arguments' => array('administer ultimate cron'),
    'type' => MENU_LOCAL_TASK,
    'file' => 'ultimate_cron.admin.inc',
  );

  ctools_include('plugins');
  $plugin_types = ctools_plugin_get_plugin_type_info();
  $weight = 0;
  foreach ($plugin_types['ultimate_cron'] as $plugin_type => $info) {
    $static = $info['defaults']['static'];
    $class = $static['class'];
    $items["admin/config/system/cron/$plugin_type"] = array(
      'type' => MENU_LOCAL_TASK,
      'title' => $static['title plural proper'],
      'description' => "Administer " . $static['title plural'],
      'page callback' => 'drupal_get_form',
      'page arguments' => array('ultimate_cron_plugin_form', $plugin_type),
      'access arguments' => array('administer ultimate cron'),
      'file' => 'ultimate_cron.admin.inc',
      'weight' => 2 + $weight,
    );
    $items["admin/config/system/cron/$plugin_type/settings"] = array(
      'type' => MENU_DEFAULT_LOCAL_TASK,
      'title' => $class::$multiple ? 'List' : 'Settings',
      'weight' => -1 + $weight,
    );
    $weight++;
    foreach (ultimate_cron_plugin_load_all($plugin_type) as $name => $plugin) {
      if (!$plugin->isValid()) {
        continue;
      }
      $items["admin/config/system/cron/$plugin_type/$name"] = array(
        'type' => MENU_LOCAL_TASK,
        'title' => $plugin->title,
        'description' => $plugin->description,
        'page callback' => 'drupal_get_form',
        'page arguments' => array('ultimate_cron_plugin_settings', $plugin_type, $name),
        'access arguments' => array('administer ultimate cron'),
        'file' => 'ultimate_cron.admin.inc',
        'weight' => $weight++,
      );
    }
  }

  return $items;
}

/**
 * Implements hook_menu_alter().
 *
 * Steal the run-cron, so when you "run cron manually" from the status-reports
 * page the ultimate_cron cron handler is run.
 */
function ultimate_cron_menu_alter(&$items) {
  // Relocate ctools export ui to main tab.
  $items['admin/config/system/cron'] = $items['admin/config/system/cron/jobs'];
  $items['admin/config/system/cron/jobs'] = array(
    'title' => 'Jobs',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => 20,
  );
  unset($items['admin/config/system/cron']['type']);

  $steal = &$items['admin/reports/status/run-cron'];
  $steal['page callback'] = 'ultimate_cron_run_scheduled';
  $steal['page arguments'] = array();
  $steal['module'] = 'ultimate_cron';
  $steal['file'] = 'ultimate_cron.module';
}

/**
 * Implements hook_permission().
 */
function ultimate_cron_permission() {
  return array(
    'administer ultimate cron' => array(
      'title' => t('Administer Ultimate Cron'),
      'description' => t('Lets you configure everything in Ultimate Cron')
    )
  );
}

/**
 * Implements hook_cron_queue_info().
 *
 * Used for code injection in order to hijack cron runs.
 */
function ultimate_cron_cron_queue_info() {
  static $processed = FALSE;
  if (!$processed) {
    $processed = TRUE;
    if (basename($_SERVER['PHP_SELF']) == 'cron.php') {
      ultimate_cron_cron_run();
      exit;
    }
  }
  return array();
}


/**
 * Implements hook_cronapi().
 *
 * Exposes hook_cron() and cron queues to Ultimate Cron.
 */
function ultimate_cron_cronapi() {
  $items = array();

  $items['ultimate_cron_cleanup_log'] = array(
    'title' => t('Cleanup Ultimate Cron log entries'),
    'callback' => array('UltimateCronLogger', 'cleanupLogs'),
  );

  // Grab the defined cron queues.
  $queues = _ultimate_cron_get_queues();

  foreach ($queues as $name => $info) {
    $items['queue_' . $name] = array(
      'title' => t('Queue: !name', array('!name' => $name)),
      'callback' => 'ultimate_cron_queue_cron',
      'callback_arguments' => array('queue_name' => $name),
      'scheduler' => array(
        // 'name' => 'simple',
        'simple' => array(
          'rules' => array('* * * * *'),
        ),
        'crontab' => array(
          'rules' => array('* * * * *'),
        ),
      ),
      'tags' => array('queue'),
      'module' => $info['module'],
    );
  }
  return $items;
}

/**
 * Process a cron queue.
 */
function ultimate_cron_queue_cron($job, $arguments) {
  $queues = _ultimate_cron_get_queues();
  $info = $queues[$arguments['queue_name']];

  $function = $info['worker callback'];
  $end = $_SERVER['REQUEST_TIME'] + (isset($info['time']) ? $info['time'] : 15);
  $queue = DrupalQueue::get($arguments['queue_name']);
  $items = 0;
  $settings = $job->getPluginSettings('settings');

  while (time() < $end && $item = $queue->claimItem($settings['queue']['queue_lease_time'])) {;
    $function($item->data);
    $queue->deleteItem($item);
    $items++;
  }
  sleep(30);
  #drupal_set_message(t('Processed @items items', array('@items' => $items)));
  watchdog($job->hook['module'], 'Processed @items items from queue @queue', array(
    '@items' => $items,
    '@queue' => $arguments['queue_name'],
  ), WATCHDOG_INFO);

  return;
}

/**
 * Implements hook_init().
 */
function ultimate_cron_init() {
  // No need for hocus pocus and poorman until site is installed.
  if (variable_get('install_task') != 'done') {
    return;
  }

  _ultimate_cron_variable_load('cron_last');
}

// ---------- FIXUPS FOR CORE  ----------

/**
 * Implements hook_cron_alter().
 *
 * Add better description to core modules.
 */
function ultimate_cron_cron_alter(&$hooks) {
  $update['dblog_cron']['title'] = t('Remove expired log messages and flood control events');
  $update['field_cron']['title'] = t('Purges deleted Field API data');
  $update['filter_cron']['title'] = t('Expire outdated filter cache entries');
  $update['node_cron']['title'] = t('Mark old nodes as read');
  $update['search_cron']['title'] = t('Update indexes');
  $update['system_cron']['title'] = t('Cleanup (batch, flood, temp-files, etc.)');
  $update['aggregator_cron']['title'] = t('Refresh feeds');
  $update['openid_cron']['title'] = t('Remove expired nonces from the database');
  $update['ping_cron']['title'] = t('Notify remote sites');
  $update['poll_cron']['title'] = t('Close expired polls');
  $update['statistics_cron']['title'] = t('Reset counts and clean up');
  $update['trigger_cron']['title'] = t('Run actions for cron triggers');
  $update['tracker_cron']['title'] = t('Update tracker index');
  $update['update_cron']['title'] = t('Check system for updates');
  $update['dblog_cron']['configure'] = 'admin/config/development/logging';

  foreach ($update as $name => $data) {
    if (isset($hooks[$name])) {
      foreach ($data as $key => $value) {
        $hooks[$name][$key] = $value;
      }
    }
  }
}

// ---------- CALLBACK FUNCTIONS ----------

/**
 * Run cron.
 *
 * The cron handler takes over the normal Drupal cron handler,
 * and runs the normal hook_cron() plus the hook_cronapi().
 *
 * @param boolean $return
 *   return to caller if TRUE, otherwise exit().
 */
function ultimate_cron_cron_run() {
  if (variable_get('install_task', FALSE) != 'done') {
    return;
  }

  // If run from core cron through CLI then don't do anything (drush core-cron)
  if (!$return && drupal_is_cli()) {
    return;
  }

  ultimate_cron_run_scheduled(FALSE);
  exit;
}

// ---------- HELPER FUNCTIONS ----------

/**
 * Load a variable by-passing the cache.
 */
function _ultimate_cron_variable_load($name) {
  if ($value = db_query("SELECT value FROM {variable} WHERE name = :name", array(':name' => $name))->fetchField()) {
    $value = unserialize($value);
  }
  global $conf;
  $conf[$name] = $value;
}

/**
 * Variable set with cache by-pass.
 */
function _ultimate_cron_variable_save($name, $value) {
  global $conf;
  db_merge('variable')->key(array('name' => $name))->fields(array('value' => serialize($value)))->execute();
  $conf[$name] = $value;
}

/**
 * Get cron queues and static cache them.
 */
function _ultimate_cron_get_queues() {
  static $queues = NULL;
  if (!isset($queues)) {
    $queues = array();
    foreach (module_implements('cron_queue_info') as $module) {
      $items = module_invoke($module, 'cron_queue_info');
      foreach ($items as &$item) {
        $item['module'] = $module;
      }
      $queues += $items;
    }
    // $queues = module_invoke_all('cron_queue_info');
    drupal_alter('cron_queue_info', $queues);
  }
  return $queues;
}

function ultimate_cron_get_hook($name, $reset = FALSE) {
  $jobs = ultimate_cron_get_hooks($reset);
  return $jobs[$name];
}

/**
 * Get jobs declared by a module.
 *
 * @param string $module
 *   Name of module.
 *
 * @return array
 *   Job definitions.
 */
function ultimate_cron_get_module_hooks($module) {
  $items = module_invoke($module, 'cronapi', NULL);

  $items = $items ? $items : array();

  if (!is_array($items)) {
    // API Version 1.x
    $list = module_invoke($module, 'cronapi', 'list');
    if (!$list) {
      $list = array();
    }
    foreach ($list as $name => $title) {
      $items[$name] = array('title' => $title);
    }
    foreach ($items as $name => &$item) {
      $item['api_version'] = 1;
      $rules = module_invoke($module, 'cronapi', 'rule', $name);
      $rules = $rules ? $rules : array();

      $settings = (array) module_invoke($module, 'cronapi', 'settings', $name);
      if (empty($settings['rules']) && $rules) {
        $settings['rules'] = $rules;
      }

      if (!empty($settings['rules'])) {
        $settings['scheduler'] = array(
          'scheduler' => 'crontab',
          'crontab' => array(
            'rules' => $settings['rules']
          ),
        );
        unset($settings['rules']);
      }

      $settings += array(
        'configure' => module_invoke($module, 'cronapi', 'configure', $name),
      );
      $item += $settings;
    }
  }

  // Add hook_cron() if applicable.
  if (empty($items["{$module}_cron"]) && module_hook($module, 'cron')) {
    $file = drupal_get_path('module', $module) . '/' . $module . '.info';
    $info = drupal_parse_info_file($file);
    $items["{$module}_cron"] = array(
      'module' => $module,
      'title' => 'Default cron handler',
      'configure' => empty($info['configure']) ? NULL : $info['configure'],
    );
  }

  // Add default settings.
  static $plugin_types;
  static $plugins;
  if (!isset($plugin_types)) {
    $plugin_types = ctools_plugin_get_plugin_type_info();
    $plugins = array();
    foreach ($plugin_types['ultimate_cron'] as $plugin_type => $info) {
      $plugins[$plugin_type] = ultimate_cron_plugin_load_all($plugin_type);
    }
  }

  foreach ($items as $name => &$item) {
    foreach ($plugin_types['ultimate_cron'] as $plugin_type => $info) {
      $static = $info['defaults']['static'];
      $class = $static['class'];
      $item += array(
        $plugin_type => array(),
      );
      if (!$class::$multiple) {
        $item[$plugin_type] += array(
          'name' => variable_get('ultimate_cron_default_plugin_' . $plugin_type, $static['default plugin']),
        );
      }

      foreach ($plugins[$plugin_type] as $plugin_name => $plugin) {
        if (!$plugin->isValid()) {
          continue;
        }
        $item[$plugin_type] += array(
          $plugin_name => array(),
        );
      }
    }

    $item += array(
      'title' => $name,
      'description' => isset($item['title']) ? $item['title'] : $name,
      'module' => $module,
      'file path' => drupal_get_path('module', $module),
      'callback_arguments' => array(),
      'callback' => $name,
      'enabled' => TRUE,
      'tags' => array(),
      'api_version' => 2,
    );
  }

  return $items;
}

/**
 * Get cron jobs available.
 *
 * @return array
 *   List of jobs.
 */
function ultimate_cron_get_hooks($reset = FALSE) {
  static $cache = NULL;
  if (!$reset && isset($cache)) {
    return $cache;
  }

  $hooks = array();
  // Generate list of jobs.
  $modules = module_list();
  foreach ($modules as $module) {
    $hooks += ultimate_cron_get_module_hooks($module);
  }

  // Allow other to manipulate the hook list.
  drupal_alter('cron', $hooks);

  return $hooks;
}

// ---------- CRON RULE FUNCTIONS ----------

function ultimate_cron_plugin_crontab_element_validate_rule($element, &$form_state) {
  $rules = array();
  $value = $element['#value'];
  if (!empty($value)) {
    $rules = explode(',', $value);
    $rules = array_map('trim', $rules);
  }
  foreach ($rules as $rule) {
    if (!ultimate_cron_validate_rule($rule)) {
      form_error($element, t('%name: %rule is not a valid rule.', array('%name' => $element['#title'], '%rule' => $rule)));
    }
  }
}

/**
 * Check if rule is valid.
 *
 * @param $rule
 *   rule to validate.
 * @return
 *   TRUE if valid, FALSE if not.
 */
function ultimate_cron_validate_rule($rule) {
  require_once 'CronRule.class.php';
  $cron = new CronRule($rule);
  if (!$cron->isValid()) {
    return FALSE;
  }
  else {
    return TRUE;
  }
}


/**
 * Return blank values for all keys in an array.
 *
 * @param array $array
 *   Array to generate blank values from.
 *
 * @return array
 *   Array with same keys as input, but with blank values (empty string).
 */
function ultimate_cron_blank_values($array) {
  $result = array();
  foreach ($array as $key => $value) {
    switch (gettype($value)) {
      case 'array':
        $result[$key] = array();
        break;

      default:
        $result[$key] = '';
    }
  }
  return $result;
}

function ultimate_cron_run_scheduled($redirect = TRUE) {
  ctools_include('export');
  $jobs = ctools_export_crud_load_all('ultimate_cron_job');

  // Find jobs that should run now.
  $schedule = array();
  foreach ($jobs as $name => $job) {
    if (empty($job->disabled) && $job->schedule()) {
      $schedule[$name] = $job;
    }
  }
  drupal_alter('cron_schedule', $schedule);

  $launcher_schedule = array();
  foreach ($schedule as $name => $job) {
    $class = get_class($job->getPlugin('launcher'));
    $launcher_schedule[$class][$name] = $job;
  }

  _ultimate_cron_variable_save('cron_last', time());

  ctools_include('plugins');
  $plugin_types = ctools_plugin_get_plugin_type_info();
  foreach ($launcher_schedule as $class => $jobs) {
    $class::launchJobs($jobs);
  }

  if ($redirect) {
    drupal_goto('admin/config/system/cron');
  }
}

function ultimate_cron_watchdog(array $log_entry) {
  UltimateCronLogger::hook_watchdog($log_entry);
}

function ultimate_cron_background_process_legacy_callback($name, $lid) {
  error_log("HERE: $name - $lid!");
  $job = ultimate_cron_job_load($name);

  $log = $job->loadLog($lid);

  $log->finished = FALSE;
  $log->catchMessages();

  // Run job.
  try {
    $job->run();
  }
  catch (Exception $e) {
    watchdog('ultimate_cron', 'Error executing %job: @error', array('%job' => $job->name, '@error' => $e->getMessage()), WATCHDOG_ERROR);
  }

  $log->finish();
}
