<?php
/**
 * @file
 * 
 * @todo Add filter on overview page.
 * @todo Add log view (with graph).
 * @todo Make proper markup for overview page.
 * @todo Store drupal messages in log on success.
 * @todo get_hooks, get_schedule, cron_cron and more are massive.
 *       Split them up and make a cleaner abstraction layer.
 *
 * hook_cron_alter(&$hooks)
 * hook_cron_schedule_alter(&$hooks)
 * hook_cron_pre_execute($function, $hook)
 * hook_cron_pre_execute_FUNCTION($hook)
 * hook_cron_post_execute($function, $hook)
 * hook_cron_post_execute_FUNCTION($hook)
 */

/**
 * Maximum number of simultaneous connections.
 */
define('ULTIMATE_CRON_SIMULTANEOUS_CONNECTIONS', 40);

/**
 * Default rule.
 */
define('ULTIMATE_CRON_RULE',         '*/10 * * * *');

/**
 * Default rule for easy hook "hourly".
 */
define('ULTIMATE_CRON_HOURLY_RULE',  '0 * * * *');

/**
 * Default rule for easy hook "daily".
 */
define('ULTIMATE_CRON_DAILY_RULE',   '0 0 * * *');

/**
 * Default rule for easy hook "weekly".
 */
define('ULTIMATE_CRON_WEEKLY_RULE',  '0 0 * * 1');

/**
 * Default rule for easy hook "monthly".
 */
define('ULTIMATE_CRON_MONTHLY_RULE', '0 0 1 * *');

/**
 * Default rule for easy hook "yearly".
 */
define('ULTIMATE_CRON_YEARLY_RULE',  '0 0 1 1 *');

/**
 * Default max execution time for Ultimate Cron.
 */
define('ULTIMATE_CRON_MAX_EXECUTION_TIME', 86400);

/**
 * Default catch up time for Ultimate Cron.
 */
define('ULTIMATE_CRON_CATCH_UP', 300);

/**
 * Default clean up time for log entries (30 days).
 */
define('ULTIMATE_CRON_CLEANUP_LOG', 86400 * 30);

/**
 * Default setting for poorman.
 */
define('ULTIMATE_CRON_POORMAN', FALSE);

// ---------- HOOKS ----------

/**
 * Implementation of hook_help().
 */
function ultimate_cron_help($path, $arg) {
  switch ($path) {
    case 'admin/help#ultimate_cron':
      // Return a line-break version of the module README
      return '<pre>'. file_get_contents( dirname(__FILE__) .'/README.txt') .'</pre>';
    case 'admin/build/cron':
      return '<p>'. t('Here you can see the crontab settings for each job available') .'</p>';
    case 'admin/build/cron/settings':
      return '<p>'. t('Here you can change the crontab settings for each job available') .'</p>';
  }
}

/**
 * Implementation of hook_menu().
 */
function ultimate_cron_menu() {
  $items = array();
  $items['admin/config/system/cron/settings'] = array(
    'title' => 'Settings',
    'description' => 'Cron settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('ultimate_cron_settings_form'),
    'access arguments' => array('administer ultimate cron'),
    'type' => MENU_LOCAL_TASK,
    'file' => 'ultimate_cron.pages.inc',
  );
  $items['admin/config/system/cron/settings/%'] = array(
    'title' => 'Settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('ultimate_cron_function_settings_form', 5),
    'access callback' => 'ultimate_cron_function_settings_form_access',
    'access arguments' => array(5),
    'weight' => 0,
    'file' => 'ultimate_cron.pages.inc',
  );
  $items['admin/ultimate-cron/service/start/%'] = array(
    'type' => MENU_CALLBACK,
    'title' => 'Run cron job',
    'description' => 'Run cron job',
    'page callback' => 'ultimate_cron_service_start',
    'page arguments' => array(4),
    'access arguments' => array('administer ultimate cron'),
    'file' => 'ultimate_cron.services.inc',
  );
  $items['admin/ultimate-cron/service/enable/%'] = array(
    'type' => MENU_CALLBACK,
    'title' => 'Enable cron job',
    'description' => 'Enable cron job',
    'page callback' => 'ultimate_cron_service_enable',
    'page arguments' => array(4, TRUE),
    'access arguments' => array('administer ultimate cron'),
    'file' => 'ultimate_cron.services.inc',
  );
  $items['admin/ultimate-cron/service/disable/%'] = array(
    'type' => MENU_CALLBACK,
    'title' => 'Disable cron job',
    'description' => 'Disable cron job',
    'page callback' => 'ultimate_cron_service_enable',
    'page arguments' => array(4, FALSE),
    'access arguments' => array('administer ultimate cron'),
    'file' => 'ultimate_cron.services.inc',
  );
  return $items;
}

/**
 * Implementation of hook_menu_alter().
 *
 * Steal the run-cron, so when you "run cron manually" from the status-reports
 * page the ultimate_cron cron handler is run.
 */
function ultimate_cron_menu_alter(&$items) {
  $items['admin/config/system/cron'] = array(
    'title' => 'Cron',
    'description' => 'View and manage cron table',
    'page callback' => 'ultimate_cron_view_page',
    'access arguments' => array('administer ultimate cron'),
    'module' => 'ultimate_cron',
    'file' => 'ultimate_cron.pages.inc',
  );
  $items['admin/config/system/cron/overview'] = array(
    'title' => 'List',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );
  $steal = &$items['admin/reports/status/run-cron'];
  $steal['page callback'] = 'ultimate_cron_run_cron';
  $steal['page arguments'] = array();
  $steal['module'] = 'ultimate_cron';
  $steal['file'] = 'ultimate_cron.pages.inc';
}

/**
 * Implementation of hook_perm().
 */
function ultimate_cron_perm() {
  return array('administer ultimate cron');
}

/**
 * Implementation of hook_cron().
 *
 * The cron handler takes over the normal Drupal cron handler
 * and runs the normal hook_cron() plus the hook_cronapi().
 *
 * @param boolean $return
 *   return to caller if TRUE, otherwise exit().
 */
function ultimate_cron_cron($return = FALSE) {
  _ultimate_cron_cron($return);
}

function _ultimate_cron_cron($return) {
  // Use no more than 2 minutes for launcing process!
  set_time_limit(120);
  
  // Don't mess up session
  drupal_save_session(FALSE);
  
  $msc = variable_get('ultimate_cron_simultaneous_connections', ULTIMATE_CRON_SIMULTANEOUS_CONNECTIONS);

  // Get list of cron hooks.
  $hooks = ultimate_cron_get_hooks();

  // Get schedule.
  $schedule = ultimate_cron_get_schedule($hooks);
  
  // Start the jobs. Keep launching jobs until 55 seconds into the request.
  $time = time();
  $expire = $time + 55;
  $running = array();
  $launched = 0;

  while (!empty($schedule) && time() < $expire) {
    // If maximum number of connections are running, wait .5 seconds, and then 
    // try again.
    $r = db_query("SELECT COUNT(1) AS running FROM {background_process}")->fetchField();
    if ($r > $msc) {
      usleep(500000);
      continue;
    }
    watchdog('ultimate_cron', "Jobs waiting to be launched: %jobs", array('%jobs' => count($schedule)), WATCHDOG_DEBUG);
    // Launch jobs.
    reset($schedule);
    while (count($running) < $msc && list($function, $hook) = each($schedule)) {
      // How to combine this with the background process ass module?
      if ($hook['background_process']) {
        // Already running, skip it.
        unset($schedule[$function]);
      }
      
      watchdog('ultimate_cron', "Checking: $function");
      $result = ultimate_cron_execute($function, $hook);

      // Handle errors.
      if ($result) {
        $handle = 'ultimate_cron:' . $hook['fid'];
        $running[$handle] = $result;
        unset($schedule[$function]);
        $launched++;
      }
      else {
        if ($result === FALSE) {
          // Could not get lock, skip job.
          unset($schedule[$function]);
        }
        else {
          // Failed to start, retry next time.
          watchdog('ultimate_cron', "Error starting $function");
        }
      }
    }


    // Jobs running ... check for start
    watchdog('ultimate_cron', "Jobs waiting to begin: %jobs", array('%jobs' => count($running)), WATCHDOG_DEBUG);
    if ($running) {
      $result = db_query("SELECT p.name FROM {progress} p WHERE p.name IN (:running)", array(':running' => array_keys($running)));
      while ($handle = $result->fetchObject()) {
        fclose($running[$handle->name]);
        unset($running[$handle->name]);
      }
    }
  }

  // Update drupals cron timestamp
  variable_set('cron_last', time());

  // And we're done ...
  if ($return) {
    return empty($schedule);
  }
  else {
    exit;
  }
}

/**
 * Implements hook_cronapi().
 */
function ultimate_cron_cronapi($op, $job = NULL) {
  switch ($op) {
    case 'list':
      $jobs['ultimate_cron_cleanup_log'] = t('Cleanup log entries');

      // Grab the defined cron queues.
      $queues = module_invoke_all('cron_queue_info');
      drupal_alter('cron_queue_info', $queues);
      foreach ($queues as $queue_name => $info) {
        // error_log($queue_name);
        // error_log(print_r($info, TRUE));
        $jobs['ultimate_cron_queue_' . $queue_name] = t('Queue: %name', array('%name' => $queue_name));
      }
      return $jobs;
    case 'execute':
      $queue_name = str_replace('ultimate_cron_queue_', '', $job);
      if ($queue_name === $job) {
        return;
      }

      // Grab the defined cron queues.
      static $queues = NULL;
      if (!isset($queues)) {
        $queues = module_invoke_all('cron_queue_info');
        drupal_alter('cron_queue_info', $queues);
      }
      $info = $queues[$queue_name];
      
      $function = $info['worker callback'];
      $end = time() + (isset($info['time']) ? $info['time'] : 15);
      $queue = DrupalQueue::get($queue_name);
      while (time() < $end && ($item = $queue->claimItem())) {
        $function($item->data);
        $queue->deleteItem($item);
      }
      return;
      
    case 'configure':
      return array(
        'ultimate_cron_cleanup_log' => 'admin/config/system/cron/settings',
        'dblog_cron' => 'admin/config/development/logging',
        'update_cron' => 'admin/reports/updates/settings',
      );
  }
}

/**
 * Implementation of hook_requirements().
 */
function ultimate_cron_requirements($phase) {
  $response = array();
  switch ($phase) {
    case 'install':
      return $response;
    case 'runtime':
      $response['title'] = 'Ultimate Cron';
      $response['value'] = 'OK';
      if ($modules = ultimate_cron_uncronable_modules()) {
        $response['severity'] = REQUIREMENT_WARNING;
        $response['value'] = t('Running in degraded mode');
        $response['description'] = t('Ultimate Cron is not the first module. Please change module weight to enable Ultimate Cron handling for all module.');
        $response['description'] .= '<br/>';
        $response['description'] .= t('Modules not handled by Ultimate Cron: %modules', array('%modules' => join(', ', array_keys($modules))));
      }
      $result = array();
      $result['ultimate_cron'] = $response;
      return $result;
  }
}

/**
 * Implements hook_theme_registry_alter().
 */
function ultimate_cron_theme_registry_alter(&$theme_registry) {
  $theme_registry['page']['theme paths'][] = drupal_get_path('module', 'ultimate_cron') . '/templates';
}

/**
 * Implementation of hook_watchdog().
 */
function ultimate_cron_watchdog($log = array()) {
  $record = &drupal_static('ultimate_cron_record', FALSE);
  if ($record && $log['severity'] <= WATCHDOG_WARNING) {
    $log['variables'] = is_array($log['variables']) ? $log['variables'] : array();
    ultimate_cron_record_log(t($log['message'], $log['variables']));
  }
}

/**
 * Implements hook_exit().
 */
function ultimate_cron_exit($destination = NULL) {
  if (variable_get('ultimate_cron_poorman', ULTIMATE_CRON_POORMAN)) {
    $last = variable_get('cron_last', 0);
    $last = floor($last / 60) * 60;
    $time = time();
    $time = floor($time / 60) * 60;
    if ($last && $last < $time) {
      error_log('launching poorman');
      $handle = 'ultimate_cron_poorman';
      // @todo Implement atomic reacquiring lock!
      if ($process = background_process_get_process($handle)) {
        if ($process->start + 120 < time()) {
          // Must have timed out or something ... remove it!
          background_process_remove_process($handle);
          $process = NULL;
        }
      }
      if (!$process) {
        background_process_start_locked($handle, '_ultimate_cron_poorman');
      }
    }
  }
}

function _ultimate_cron_poorman() {
  if (!variable_get('ultimate_cron_poorman', ULTIMATE_CRON_POORMAN)) {
    return;
  }
  background_process_keepalive();
  $time = time();
  $time = floor($time / 60) * 60;
  $expire = $time + 30;
  error_log('starting poorman');
  error_log('Running poorman: ' . date('Y-m-d H:i:s', $time));
  _ultimate_cron_cron(TRUE);
  $wait = $time + 60 - time();
  if ($wait > 0 && $wait <= 60) {
    error_log("Sleeping: $wait");
    sleep($wait);
  }
  error_log('exiting poorman');
}


// ---------- HELPER FUNCTIONS ----------

/**
 * Clean up log entries.
 */
function ultimate_cron_cleanup_log() {
  // return db_query_range("DELETE FROM {ultimate_cron_log} WHERE start < %d", time() - variable_get('ultimate_cron_cleanup_log', ULTIMATE_CRON_CLEANUP_LOG), 0, 1000);
}

/**
 * Access handler for function configuration.
 *
 * @param $function
 *   Function name.
 * @return boolean
 *   Access granted/denied.
 */
function ultimate_cron_function_settings_form_access($function) {
  if (!$function || !is_string($function)) {
    return FALSE;
  }

  $hooks = ultimate_cron_get_hooks();
  if (!isset($hooks[$function])) {
    return FALSE;
  }

  return user_access('administer ultimate cron');
}

/**
 * Execute a cron hook.
 * 
 * @param $function
 * @param $hook
 * @return mixed
 *   Connections file handle on success.
 */
function ultimate_cron_execute($function, $hook) {
  // Run the job in background
  if ($fid = ultimate_cron_get_function_id($function)) {
    $handle = "ultimate_cron:" . $fid;
    $process = new BackgroundProcess($handle);
    // Always run cron job as anonymous user
    $process->uid = 0;
    if (!empty($hook['configuration']['service_group'])) {
      $process->service_group = $hook['configuration']['service_group'];
    }
    $result = $process->start('ultimate_cron_run_hook', array($function, $hook));
  }
  return $result ? $process->connection : $result;
}

/**
 * Run the cron hook.
 *
 * @param $module
 *   Module containing function.
 * @param $function
 *   Function to call.
 * @return boolean
 *   TRUE on success, FALSE on failure.
 */
function ultimate_cron_run_hook($function, $hook) {
  set_time_limit(variable_get('ultimate_cron_max_execution_time', ULTIMATE_CRON_MAX_EXECUTION_TIME));
  drupal_save_session(FALSE);

  $fid = ultimate_cron_get_function_id($function);
  if (!$fid) {
    watchdog('ultimate_cron', 'Could locate/create function id for %function', array('%function' => $function));
    return FALSE;
  }

  // Load current process
  $process = background_process_get_process(background_process_current_handle());

  $record = &drupal_static('ultimate_cron_record', FALSE);
  $record = TRUE;
  ultimate_cron_record_log(NULL, TRUE);

  $time = time();
  if (!ultimate_cron_should_run($hook['configuration']['rules'], $hook['log']['start'], $time, $hook['configuration']['catch_up'])) {
    // Hook started too late!
    watchdog('ultimate_cron', '%function skipped. Invoked at %invoke, but did not start until %start', array(
      '%function' => $function,
      '%invoke' => format_date($hook['timestamp'], 'custom', 'Y-m-d H:i:s'),
      '%start' => format_date($time, 'custom', 'Y-m-d H:i:s'),
    ), WATCHDOG_ERROR);
    ultimate_cron_background_process_shutdown($process, FALSE);
    return FALSE;
  }

  // Trap errors for logging purposes
  $callback = &drupal_static('ultimate_cron_error_handler', NULL);
  $callback = set_error_handler('_ultimate_cron_error_handler');
  
  // Let other modules do stuff before execution, if they need to.
  module_invoke_all('cron_pre_execute', $function, $hook);
  module_invoke_all('cron_pre_execute_' . $function, $hook);

  if (function_exists($function)) {
    $result = $function();
  }
  else {
    $result = module_invoke($hook['module'], 'cronapi', 'execute', $function);
  }

  ultimate_cron_background_process_shutdown($process, $result);

  // Let other modules do stuff before execution, if they need to.
  module_invoke_all('cron_post_execute', $function, $hook);
  module_invoke_all('cron_post_execute_' . $function, $hook);

  return TRUE;
}

function _ultimate_cron_error_handler($errno, $errstr, $errfile, $errline, $errcontext) {
  ultimate_cron_record_log($errstr);
  $callback = &drupal_static('ultimate_cron_error_handler');
  if (is_callable($callback)) {
    return call_user_func($callback, $errno, $errstr, $errfile, $errline, $errcontext);
  }
}

/**
 * Implements hook_background_process_shutdown().
 *
 * Shutdown handler for cronjobs.
 */
function ultimate_cron_background_process_shutdown($process, $result = NULL) {
  $msg = ultimate_cron_record_log(NULL);
  $fid = str_replace('ultimate_cron:', '', $process->handle);
  if ($fid !== $process->handle && is_numeric($fid)) {
    static $has_run = array();
    if (!empty($has_run[$fid])) {
      return;
    }
    $has_run[$fid] = TRUE;

    // Record end time
    $end = microtime(TRUE);

    // If only one argument was passed to this function, assume it was called by
    // a shutdown handler, and conclude that something went wrong.
    // If no message has been recorded, provide a default one.
    if (func_num_args() == 1) {
      $result = FALSE;
      if (!$msg) {
        $msg = t('Died unexpectedly');
      }
    }

    $messages = drupal_get_messages(NULL, TRUE);
    if (!empty($messages['error'])) {
      $msg .= join("\n", $messages['error']);
    }
    
    // If result not set by cronjob, use watchdog errors (if any) as result.
    if ($result === NULL) {
      $result = empty($msg);
    }
    if ($result && empty($msg)) {
      $msg = join("\n", $messages['status']);
    }

    // log results here ...
    $object = (object)array(
      'fid' => $fid,
      'start' => $process->start,
      'end' => $end,
      'status' => $result,
      'msg' => $msg,
    );
    drupal_write_record('ultimate_cron_log', $object);
    $function = db_query("SELECT `function` FROM {ultimate_cron_function} WHERE fid = :fid", array(':fid' => $fid))->fetchField();
    watchdog('ultimate_cron', 'Shutdown: %function (%result) - %msg', array('%function' => $function, '%result' => $result, '%msg' => $msg), WATCHDOG_DEBUG);
  }
}

/**
 * Get a list of functions that should be run now.
 *
 * @param $hooks
 *   Array of cron hooks to check.
 * @return array
 *   Functions to run now.
 */
function ultimate_cron_get_schedule($hooks) {
  // Create list of scheduled functions
  $schedule = array();
  foreach ($hooks as $function => &$hook) {
    // Is it enabled?
    if (empty($hook['configuration']['enabled'])) {
      continue;
    }

    // Get last start time from log
    $log = ultimate_cron_get_log($function);
    $hook['log'] = $log;
    if (ultimate_cron_should_run($hook['configuration']['rules'], $log['start'], time(), $hook['configuration']['catch_up'])) {
      $schedule[$function] = $hook;
    }
  }

  // Sort by last run time
  uasort($schedule, '_ultimate_cron_sort_schedule');

  // Allow other to manipulate the schedule
  drupal_alter('cron_schedule', $schedule);

  return $schedule;
}

/**
 * Sort callback for ordering schedule.
 *
 * @param type $a
 * @param type $b
 * @return type 
 */
function _ultimate_cron_sort_schedule($a, $b) {
  return $a["log"]["start"] == $b["log"]["start"] ? 0 : ($a["log"]["start"] < $b["log"]["start"] ? -1 : 1);
}

/**
 * Get cron hooks available.
 *
 * @return array
 *   List of modules.
 */
function ultimate_cron_get_hooks() {
  static $hooks = NULL;
  if (isset($hooks)) {
    return $hooks;
  }
  $hooks = array();

  // Which modules are not hook_cron() safe?
  $uncronable_modules = ultimate_cron_uncronable_modules();
  $cron_data = _ultimate_cron_preload_cron_data();

  // Get configure paths
  $configure = module_invoke_all('cronapi', 'configure');
  $modules = module_list();
  foreach ($modules as $module) {
    $info = drupal_parse_info_file(drupal_get_path('module', $module) .'/' . $module . '.info');
    if (isset($info['configure'])) {
      $function = $module . '_cron';
      if (!isset($configure[$function])) {
        $configure[$function] = $info['configure'];
      }
    }
  }
  
  // Generate list of hooks
  foreach ($modules as $module) {
    foreach (ultimate_cron_easy_hooks() as $hook => $description) {
      if (isset($uncronable_modules[$module]) && $hook === 'cron') {
        continue;
      }
      if (module_hook($module, $hook)) {
        $function = $module . '_' . $hook;
        $hooks[$function]['configuration'] = isset($cron_data[$function]['configuration']) ? $cron_data[$function]['configuration'] : array();
        ultimate_cron_sanitize_configuration($function, $module, $hooks[$function]['configuration'], ultimate_cron_easy_hooks_rule($hook));
        $hooks[$function]['description'] = $description;
        $hooks[$function]['module'] = $module;
        if ($fid = ultimate_cron_get_function_id($function)) {
          $hooks[$function]['fid'] = $fid;
          $handle = "ultimate_cron:" . $fid;
          $hooks[$function]['background_process'] = $cron_data[$function]['background_process'];
          $hooks[$function]['configure'] = isset($configure[$function]) ? $configure[$function] : NULL;
        }
      }
    }
    if ($cronapi = module_invoke($module, 'cronapi', 'list')) {
      foreach ($cronapi as $function => $description) {
        if (isset($uncronable_modules[$module]) && $hook === 'cron') {
          continue;
        }
        $hooks[$function]['configuration'] = $cron_data[$function]['configuration'];
        ultimate_cron_sanitize_configuration($function, $module, $hooks[$function]['configuration'], variable_get('ultimate_cron_rule', ULTIMATE_CRON_RULE));
        $hooks[$function]['description'] = $description;
        $hooks[$function]['module'] = $module;
        if ($fid = ultimate_cron_get_function_id($function)) {
          $hooks[$function]['fid'] = $fid;
          $handle = "ultimate_cron:" . $fid;
          $hooks[$function]['background_process'] = $cron_data[$function]['background_process'];
          $hooks[$function]['configure'] = isset($configure[$function]) ? $configure[$function] : NULL;
        }
      }
    }
  }
  
  // Remove ourselves from the list
  unset($hooks['ultimate_cron_cron']);
  unset($hooks['parallel_cron_cron']);

  // Allow other to manipulate the hook list
  drupal_alter('cron', $hooks);

  return $hooks;
}

/**
 * Find modules that precedes Ultimate Cron and therefore cannot be handled
 * by Ultimate Cron.
 *
 * @return array
 *   List of modules.
 */
function ultimate_cron_uncronable_modules() {
  $modules = array();
  foreach (module_list() as $module) {
    if ($module === 'ultimate_cron') {
      break;
    }
    $modules[$module] = $module;
  }
  return $modules;
}

/**
 * Get configuration for a function.
 *
 * @param $function
 * @param $module
 * @param $default_rule
 *   Default rule to use, if no rules found.
 * @return array
 *   Configuration for function
 */
function ultimate_cron_get_configuration($function) {
  $fid = ultimate_cron_get_function_id($function);
  if (!$fid) {
    return NULL;
  }

  $conf = db_query("SELECT fid, configuration FROM {ultimate_cron_configuration} WHERE fid = :fid", array(':fid' => $fid))->fetchObject();
  $conf = $conf && $conf->configuration ? unserialize($conf->configuration) : array();
  return $conf;
}

/**
 * Sanitize configuration.
 *
 * @param $function
 * @param $module
 * @param &$conf
 * @param $default_rule
 */
function ultimate_cron_sanitize_configuration($function, $module, &$conf, $default_rule = ULTIMATE_CRON_RULE) {
  if (isset($module)) {
    if (!is_array($conf)) {
      $conf = array();
    }
    $rule = module_invoke($module, 'cronapi', 'rule', $function);
    $rule = $rule ? $rule : $default_rule;
    
    $conf += array(
      'enabled' => TRUE,
      'rules' => array($rule),
      'catch_up' => '',
    );
  }
}

/**
 * Set configuration for a function.
 *
 * @param $function
 *   Function to set configuration for.
 * @param $conf
 *   Configuration data
 * @return boolean
 *   TRUE on success, FALSE on failure.
 */
function ultimate_cron_set_configuration($function, $conf) {
  $fid = ultimate_cron_get_function_id($function);
  if (!$fid) {
    return NULL;
  }

  return db_merge('ultimate_cron_configuration')
    ->key(array('fid' => $fid))
    ->fields(array(
      'configuration' => serialize($conf),
    ))
    ->execute();
}

/**
 * Get latest log line for a function.
 *
 * @param $function
 *   Function to get latest log line for,
 * @return object
 *   Log line.
 */
function ultimate_cron_get_log($function) {
  $log = db_query_range("
    SELECT l.* FROM {ultimate_cron_log} l
    JOIN {ultimate_cron_function} f ON l.fid = f.fid
    WHERE f.function = :function
    ORDER BY l.start DESC",
    0, 1, array(':function' => $function))
      ->fetchAssoc();
  // $log['count'] = db_result(db_query("SELECT COUNT(1) FROM {ultimate_cron_log} l JOIN {ultimate_cron_function} f ON l.fid = f.fid WHERE f.function = '%s'", $function));
  return $log;
}

/**
 * Get latest log line for a function.
 *
 * @param $function
 *   Function to get latest log line for.
 * @return object
 *   Log line.
 */
function ultimate_cron_get_logs($function) {
  $result = db_query_range("
    SELECT l.* FROM {ultimate_cron_log} l
    JOIN {ultimate_cron_function} f ON l.fid = f.fid
    WHERE f.function = :function
    ORDER BY l.start DESC",
    0, 100, array(':function' => $function));
  $logs = array();
  while ($log = $result->fetchObject()) {
    $logs[] = $log;
  }
  return $logs;
}

/**
 * Store watchdog error messages for later use.
 *
 * @staticvar string $log
 * @param $msg
 *   Message to record.
 * @param $reset
 *   Reset recorded message.
 * @return string
 *   Message recorded.
 */
function ultimate_cron_record_log($msg = NULL, $reset = FALSE) {
  static $log = '';
  if ($reset) {
    $log = '';
  }
  if ($msg) {
    $log .= "$msg\n";
  }
  return $log;
}

/**
 * Check if rule is valid.
 *
 * @param $rule
 *   rule to validate.
 * @return
 *   TRUE if valid, FALSE if not.
 */
function ultimate_cron_validate_rule($rule) {
  require_once(drupal_get_path('module', 'ultimate_cron') . '/CronRule.class.php');
  $cron = new CronRule($rule);
  if (!$cron->isValid()) {
    return FALSE;
  }
  else {
    return TRUE;
  }
}

/**
 * Check if rule is scheduled to run at a given time.
 *
 * @param $rules
 *   rules to validate.
 * @param $last_run
 *   last time the rule was run.
 * @param $now
 *   time of validation, set to NULL for now.
 * @param $catch_up
 *   run if we missed our time window?
 * @return boolean
 *   TRUE if rule is scheduled to run, FALSE if not.
 */
function ultimate_cron_should_run($rules, $last_run, $now = NULL, $catch_up = 0) {
  if ($catch_up == '') {
    $catch_up = variable_get('ultimate_cron_catch_up', ULTIMATE_CRON_CATCH_UP);
  }
  $now = is_null($now) ? time() : $now;
  require_once(drupal_get_path('module', 'ultimate_cron') . '/CronRule.class.php');
  foreach ($rules as $rule) {
    $cron = new CronRule($rule);
    $last_ran = $cron->getLastRan();
    if ($last_run < $last_ran && ($catch_up || ($last_ran <= floor(($now - $cactch_up) / 60) * 60))) {
      return TRUE;
    }
  }
  return FALSE;
}

/**
 * Get a list of the "easy-hooks".
 *
 * @return array
 *    hooks (hook_name => hook_description).
 */
function ultimate_cron_easy_hooks() {
  return array(
    'cron'    => 'Default cron handler',
    'hourly'  => 'Hourly',
    'daily'   => 'Daily',
    'weekly'  => 'Weekly',
    'monthly' => 'Monthly',
    'yearly'  => 'Yearly'
  );
}

/**
 * Get rule(s) for easy hook(s)
 *
 * @param $hook
 *   Hook to get rule for (optional).
 * @return mixed
 *   Rule for $hook if specified, otherwise all rules for all easy hooks.
 */
function ultimate_cron_easy_hooks_rule($hook = NULL) {
  $rules = array(
    'cron'    => variable_get('ultimate_cron_rule', ULTIMATE_CRON_RULE),
    'hourly'  => ULTIMATE_CRON_HOURLY_RULE,
    'daily'   => ULTIMATE_CRON_DAILY_RULE,
    'weekly'  => ULTIMATE_CRON_WEEKLY_RULE,
    'monthly' => ULTIMATE_CRON_MONTHLY_RULE,
    'yearly'  => ULTIMATE_CRON_YEARLY_RULE,
  );
  return isset($rules[$hook]) ? $rules[$hook] : variable_get('ultimate_cron_rule', ULTIMATE_CRON_RULE);
}

/**
 * Get function ID based on function name. Will create the function in the
 * ultimate_cron_function table, if it doesn't exist.
 *
 * @param $function
 *   Function name
 * @return integer
 *   Function ID.
 */
function ultimate_cron_get_function_id($function, $fid = NULL) {
  static $ids = array();
  if (isset($fid)) {
    $ids[$function] = $fid;
  }
  if (isset($ids[$function])) {
    return $ids[$function];
  }
  $fid = db_query("SELECT fid FROM {ultimate_cron_function} WHERE `function` = :function ", array(':function' => $function))->fetchField();
  if (!$fid) {
    try {
      $fid = db_insert('ultimate_cron_function')
        ->fields(array(
          'function' => $function
        ))
        ->execute();
    }
    catch (Exception $e) {
      $fid = db_query("SELECT fid FROM {ultimate_cron_function} WHERE `function` = :function ", array(':function' => $function))->fetchField();
    }
  }
  $ids[$function] = $fid;
  return $fid;
}

/**
 * Reclaims position as the first module in the module list.
 */
function ultimate_cron_reclaim() {
  $weight = db_query("SELECT MIN(weight) FROM {system}")->fetchField();
  $weight --;
  // db_query("UPDATE {system} SET weight = '%d' WHERE name = '%s'", $weight, 'ultimate_cron');
  db_update('system')
    ->fields(array(
      'weight' => $weight
    ))
    ->condition('name', 'ultimate_cron')
    ->execute();
}

/**
 * Get module name
 * @param $module
 * @return string
 *   Name of module
 */
function ultimate_cron_module_name($module) {
  $file = drupal_get_path('module', $module) .'/'. $module .'.info';
  $info = drupal_parse_info_file($file);
  return $info['name'] ? $info['name'] : $module;
}

/**
 * Load all cronjob configurations and processes.
 *
 * @return array
 *   Array of cronjobs and their data.
 */
function _ultimate_cron_preload_cron_data() {
  $result = db_query("
SELECT f.fid, f.function, c.configuration, p.handle, p.service_host
FROM ultimate_cron_function f
LEFT JOIN ultimate_cron_configuration c ON f.fid = c.fid
LEFT JOIN background_process p ON p.handle = CONCAT('ultimate_cron:', f.fid)
");

  $data = array();
  while ($row = $result->fetchObject()) {
    ultimate_cron_get_function_id($row->function, $row->fid);
    $data[$row->function] = array(
      'configuration' => $row->configuration ? unserialize($row->configuration) : array(),
      'background_process' => empty($row->handle) ? NULL : (object)array(
        'handle' => $row->handle,
        'service_host' => $row->service_host,
      ),
    );
  }
  return $data;
}
