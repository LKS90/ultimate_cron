<?php
/**
 * @file
 *
 * @todo Add filter on overview page.
 * @todo Add log view (with graph).
 * @todo Make proper markup for overview page.
 * @todo Fix catch up logic ... is buggy sometimes?
 * @todo Refactor Cron % offset stuff. Too mixed up and ungrokable code-wise and 'delta' is not consistent.
 *
 * hook_cron_alter(&$hooks)
 * hook_cron_schedule_alter(&$hooks)
 * hook_cron_pre_execute($name, $hook)
 * hook_cron_pre_execute_FUNCTION($hook)
 * hook_cron_post_execute($name, $hook)
 * hook_cron_post_execute_FUNCTION($hook)
 */

/**
 * Default rule.
 */
define('ULTIMATE_CRON_RULE',         '*/10+@ * * * *');

/**
 * Default max execution time for Ultimate Cron.
 */
define('ULTIMATE_CRON_MAX_EXECUTION_TIME', 86400);

/**
 * Default serviec group for Ultimate Cron.
 */
define('ULTIMATE_CRON_SERVICE_GROUP', 'default');

/**
 * Default catch up time for Ultimate Cron.
 */
define('ULTIMATE_CRON_CATCH_UP', 300);

/**
 * Default lease time for Ultimate Cron queues.
 */
define('ULTIMATE_CRON_QUEUE_LEASE_TIME', 30);

/**
 * Default clean up time for log entries (30 days).
 */
define('ULTIMATE_CRON_CLEANUP_LOG', 86400 * 30);

/**
 * Default setting for poorman.
 */
define('ULTIMATE_CRON_POORMAN', FALSE);

/**
 * Time in seconds to spend on launcing cron jobs.
 */
define('ULTIMATE_CRON_LAUNCH_WINDOW', 55);

// ---------- HOOKS ----------

module_load_include('nagios.inc', 'ultimate_cron');

/**
 * Implements hook_help().
 */
function ultimate_cron_help($path, $arg) {
  switch ($path) {
    case 'admin/help#ultimate_cron':
      // Return a line-break version of the module README
      return '<pre>' . file_get_contents(dirname(__FILE__) . '/README.txt') . '</pre>';
    case 'admin/build/cron':
      return '<p>' . t('Here you can see the crontab settings for each job available') . '</p>';
    case 'admin/build/cron/settings':
      return '<p>' . t('Here you can change the crontab settings for each job available') . '</p>';
  }
}

/**
 * Implements hook_menu().
 */
function ultimate_cron_menu() {
  $items = array();
  $items['admin/config/system/cron/settings'] = array(
    'title' => 'Settings',
    'description' => 'Cron settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('ultimate_cron_settings_form'),
    'access arguments' => array('administer ultimate cron'),
    'type' => MENU_LOCAL_TASK,
    'file' => 'ultimate_cron.admin.inc',
  );
  $items['admin/config/system/cron/settings/%'] = array(
    'title' => 'Settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('ultimate_cron_function_settings_form', 5),
    'access arguments' => array('administer ultimate cron'),
    'weight' => 0,
    'file' => 'ultimate_cron.admin.inc',
  );
  $items['admin/reports/cron'] = array(
    'title' => 'Cron logs',
    'description' => 'View logs for all cron jobs.',
    'page callback' => 'ultimate_cron_view_page',
    'access arguments' => array('administer ultimate cron'),
    'file' => 'ultimate_cron.admin.inc',
  );
  $items['admin/reports/cron/%'] = array(
    'title' => 'Cron log',
    'description' => 'View log for specific function.',
    'page callback' => 'ultimate_cron_function_log_page',
    'page arguments' => array(3),
    'access arguments' => array('administer ultimate cron'),
    'file' => 'ultimate_cron.admin.inc',
  );
  $items['admin/ultimate-cron/service/start/%'] = array(
    'type' => MENU_CALLBACK,
    'title' => 'Run cron job',
    'description' => 'Run cron job',
    'page callback' => 'ultimate_cron_service_start',
    'page arguments' => array(4),
    'access arguments' => array('administer ultimate cron'),
    'file' => 'ultimate_cron.admin.inc',
  );
  $items['admin/ultimate-cron/service/enable/%'] = array(
    'type' => MENU_CALLBACK,
    'title' => 'Enable cron job',
    'description' => 'Enable cron job',
    'page callback' => 'ultimate_cron_service_enable',
    'page arguments' => array(4, TRUE),
    'access arguments' => array('administer ultimate cron'),
    'file' => 'ultimate_cron.admin.inc',
  );
  $items['admin/ultimate-cron/service/disable/%'] = array(
    'type' => MENU_CALLBACK,
    'title' => 'Disable cron job',
    'description' => 'Disable cron job',
    'page callback' => 'ultimate_cron_service_enable',
    'page arguments' => array(4, FALSE),
    'access arguments' => array('administer ultimate cron'),
    'file' => 'ultimate_cron.admin.inc',
  );
  return $items;
}

/**
 * Implements hook_cron_queue_info().
 * Used for code injection in order to hijack cron runs.
 */
function ultimate_cron_cron_queue_info() {
  static $processed = FALSE;
  if (!$processed) {
    $processed = TRUE;
    if (basename($_SERVER['PHP_SELF']) == 'cron.php') {
      ultimate_cron_cron_run(FALSE);
      exit;
    }
  }
  return array();
}

/**
 * Implements hook_permission().
 */
function ultimate_cron_permission() {
  return array(
    'administer ultimate cron' => array(
      'title' => t('Administer Ultimate Cron'),
      'description' => t('Lets you configure everything in Ultimate Cron')
    )
  );
}

/**
 * Implements hook_cronapi().
 *
 * Exposes hook_cron() and cron queues to Ultimate Cron.
 */
function ultimate_cron_cronapi() {
  $items = array();

  $items['ultimate_cron_poorman'] = array(
    'description' => t('Poorman\'s Cron'),
    'rules' => array('* * * * *'),
    'enabled' => FALSE,
  );
  $items['ultimate_cron_cleanup_log'] = array(
    'description' => t('Clean up old log entries'),
    'rules' => array('* * * * *'),
  );

  // Grab the defined cron queues.
  $queues = _ultimate_cron_get_queues();

  foreach ($queues as $queue_name => $info) {
    $items['queue_' . $queue_name] = array(
      'description' => t('Queue: !name', array('!name' => $queue_name)),
      'callback' => 'ultimate_cron_queue_cron',
      'arguments' => array($queue_name),
      'rules' => array('* * * * *'),
      'queue lease time' => variable_get('ultimate_cron_queue_lease_time', ULTIMATE_CRON_QUEUE_LEASE_TIME),
    );
  }
  return $items;
}

/**
 * Implements hook_init().
 */
function ultimate_cron_init() {
  // No need for hocus pocus and poorman until site is installed.
  if (variable_get('install_task') != 'done') {
    return;
  }

  _ultimate_cron_variable_load('cron_last');

  ultimate_cron_trigger_poorman();
}

/**
 * Shutdown handler for cronjobs.
 */
function ultimate_cron_background_process_shutdown_callback($hook, $process) {
  $name = $hook['name'];
  // Record end time
  $end = microtime(TRUE);

  $log = $process->getLog();
  $msg = array();
  foreach ($log['entries'] as $entry) {
    $msg[] = trim($entry['message']);
  }

  // log results here ...
  $object = (object)array(
    'name' => $name,
    'start_time' => $process->getStartTime(),
    'end_time' => $end,
    'service_host' => (string)$process->getServiceHost(),
    'severity' => $log['severity'],
    'msg' => trim(join("\n", $msg)),
  );
  drupal_write_record('ultimate_cron_log', $object);

  $object->formatted['start_time'] = format_date((int)$object->start_time, 'custom', 'Y-m-d H:i:s');
  $object->formatted['end_time'] = format_date((int)$object->end_time, 'custom', 'Y-m-d H:i:s');
  $object->formatted['duration'] = gmdate('H:i:s', (int)($object->end_time - $object->start_time));
  $object->formatted['severity'] = $object->severity < 0 ? 'success' : ($object->severity >= WATCHDOG_NOTICE ? 'info' : ($object->severity >= WATCHDOG_WARNING ? 'warning' : 'error'));
  $object->formatted['severity'] = $object->msg && ($object->formatted['severity'] == 'success') ? 'info' : $object->formatted['severity'];
  $object->formatted['executeURL'] = url('admin/ultimate-cron/service/start/' . $object->name, array('query' => drupal_get_destination()));
  if (module_exists('nodejs')) {
    $message = (object) array(
      'channel' => 'ultimate_cron',
      'data' => (object) array(
        'action' => 'log',
        'log' => $object,
      ),
      'callback' => 'nodejsUltimateCron',
    );
    nodejs_send_content_channel_message($message);
  }
}


// ---------- FIXUPS FOR CORE  ----------

/**
 * Implements hook_menu_alter().
 *
 * Steal the run-cron, so when you "run cron manually" from the status-reports
 * page the ultimate_cron cron handler is run.
 */
function ultimate_cron_menu_alter(&$items) {
  $items['admin/config/system/cron'] = array(
    'title' => 'Cron',
    'description' => 'View and manage cron table',
    'page callback' => 'ultimate_cron_view_page',
    'access arguments' => array('administer ultimate cron'),
    'module' => 'ultimate_cron',
    'file' => 'ultimate_cron.admin.inc',
  );
  $items['admin/config/system/cron/overview'] = array(
    'title' => 'List',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );
  $steal = &$items['admin/reports/status/run-cron'];
  $steal['page callback'] = 'ultimate_cron_service_start';
  $steal['page arguments'] = array();
  $steal['module'] = 'ultimate_cron';
  $steal['file'] = 'ultimate_cron.admin.inc';
}

/**
 * Implements hook_cron_alter().
 * Add better description to core modules.
 */
function ultimate_cron_cron_alter(&$hooks) {
  $update['dblog_cron']['description'] = t('Remove expired log messages and flood control events');
  $update['field_cron']['description'] = t('Purges deleted Field API data');
  $update['filter_cron']['description'] = t('Expire outdated filter cache entries');
  $update['node_cron']['description'] = t('Mark old nodes as read');
  $update['search_cron']['description'] = t('Update indexes');
  $update['system_cron']['description'] = t('Cleanup (batch, flood, temp-files, etc.)');
  $update['aggregator_cron']['description'] = t('Refresh feeds');
  $update['openid_cron']['description'] = t('Remove expired nonces from the database');
  $update['ping_cron']['description'] = t('Notify remote sites');
  $update['poll_cron']['description'] = t('Close expired polls');
  $update['statistics_cron']['description'] = t('Reset counts and clean up');
  $update['trigger_cron']['description'] = t('Run actions for cron triggers');
  $update['tracker_cron']['description'] = t('Update tracker index');
  $update['update_cron']['description'] = t('Check system for updates');
  $update['ultimate_cron_cleanup_log']['configure'] = 'admin/config/system/cron/settings';
  $update['dblog_cron']['configure'] = 'admin/config/development/logging';

  foreach ($update as $name => $data) {
    if (isset($hooks[$name])) {
      foreach ($data as $key => $value) {
        $hooks[$name][$key] = $value;
      }
    }
  }
}

/**
 * Implements hook_background_process_message_alter().
 */
function ultimate_cron_background_process_message_alter($message) {
  // Only alter Ultimate Cron background process messages
  if (substr($message->data->background_process->getHandle(), 0, 3) !== 'uc:') {
    return;
  }

  $message->data->ultimate_cron['start_time'] = format_date((int)$message->data->background_process->getStartTime(), 'custom', 'Y-m-d H:i:s');
  if ($message->data->background_process->getProgress() >= 0) {
    $message->data->ultimate_cron['progress'] = gmdate('H:i:s', (int)(microtime(TRUE) - $message->data->background_process->getStartTime())) . sprintf(" (%3d%%)", $message->data->background_process->getProgress() * 100);
  }
  $message->data->ultimate_cron['unlockURL'] = url('background-process/unlock/' . $message->data->background_process->getPID(), array('query' => drupal_get_destination()));
}


// ---------- CALLBACK FUNCTIONS ----------

/**
 * The cron handler takes over the normal Drupal cron handler
 * and runs the normal hook_cron() plus the hook_cronapi().
 *
 * @param boolean $return
 *   return to caller if TRUE, otherwise exit().
 */
function ultimate_cron_cron_run($return = FALSE) {
  if (variable_get('install_task', FALSE) != 'done') {
    return;
  }

  // If run from core cron through CLI then don't do anything (drush core-cron)
  if (!$return && drupal_is_cli()) {
    return;
  }

  // Acquire lock
  if (!lock_acquire('cron', 240.0)) {
    drupal_set_message(t('Ultimate Cron launcher already running'), 'error');
    return;
  }

  // Get list of cron hooks.
  $hooks = ultimate_cron_get_hooks();

  // Get schedule.
  $schedule = ultimate_cron_get_schedule($hooks);
  $scheduled = count($schedule);

  drupal_set_message(t('%jobs jobs scheduled for launch', array('%jobs' => $scheduled)));

  // Start the jobs. Keep launching jobs until X seconds into the request.
  set_time_limit(120);
  $time = time();
  $expire = $time + variable_get('ultimate_cron_launch_window', ULTIMATE_CRON_LAUNCH_WINDOW);
  $running = array();
  $launched = 0;
  $finished = FALSE;

  // Try to launch jobs within the given time frame
  while (!$finished && time() < $expire) {
    // Launch jobs.
    reset($schedule);
    while ((list($name, $hook) = each($schedule)) && time() < $expire) {
      if ($hook['background_process']) {
        // Already running, don't launch
        unset($schedule[$name]);
        continue;
      }
      try {
        $process = ultimate_cron_run_hook($hook);
        $running[$process->handle] = $process;
        unset($schedule[$name]);
        $launched++;
        drupal_set_message(t('Launched !name', array('!name' => $name)));
      }
      catch (Exception $e) {
        // Could not launch? ... let's retry
      }
    }

    $finished = empty($schedule);
    sleep(1);
  }

  // Wait for processes to start
  while ($running && time() < $expire) {
    $handles = db_select('background_process', 'bp', array('target' => 'background_process'))
              ->fields('bp', array('handle', 'pid'))
              ->condition('bp.handle', array_keys($running), 'IN')
              ->condition('bp.exec_status', BACKGROUND_PROCESS_STATUS_LOCKED)
              ->execute()
              ->fetchAllKeyed(0, 0);
    foreach ($running as $handle => $process) {
      if (!in_array($handle, $handles)) {
        unset($running[$handle]);
      }
    }
    sleep(1);
  }

  // Update drupals cron timestamp, but don't clear the cache for all variables!
  _ultimate_cron_variable_set('cron_last', time());

  $time = time() - $time;

  foreach ($running as $handle => $process) {
    watchdog('ultimate_cron', 'Failed to launch !handle', array('!handle' => $handle), WATCHDOG_ERROR);
  }

  $running = count($running);

  drupal_set_message(t('%jobs jobs launched in %time seconds', array('%jobs' => $launched - $running, '%time' => $time)));

  if ($running) {
    drupal_set_message(t('%jobs jobs failed to launch within %seconds seconds', array(
      '%jobs' => $running,
      '%seconds' => $time,
    )), 'error');
    watchdog('ultimate_cron', '%jobs jobs failed to launch within %seconds seconds', array(
      '%jobs' => $running,
      '%seconds' => $time,
    ), WATCHDOG_WARNING);
  }


  // Release the lock
  lock_release('cron');

  // And we're done ...
  if ($return) {
    return empty($running);
  }
  else {
    exit;
  }
}

/**
 * Process a cron queue.
 */
function ultimate_cron_queue_cron($hook, $queue_name) {
  $queues = _ultimate_cron_get_queues();
  $info = $queues[$queue_name];

  $function = $info['worker callback'];
  $end = $_SERVER['REQUEST_TIME'] + (isset($info['time']) ? $info['time'] : 15);
  $queue = DrupalQueue::get($queue_name);
  $items = 0;
  while (time() < $end && $item = $queue->claimItem($hook['queue lease time'])) {;
    $function($item->data);
    $queue->deleteItem($item);
    $items++;
  }
  drupal_set_message(t('Processed @items items', array('@items' => $items)));

  return;
}

// ---------- HELPER FUNCTIONS ----------

/**
 * Load a variable by-passing the cache
 */
function _ultimate_cron_variable_load($name) {
  if ($value = db_query("SELECT value FROM {variable} WHERE name = :name", array(':name' => $name))->fetchField()) {
    $value = unserialize($value);
  }
  global $conf;
  $conf[$name] = $value;
}

/**
 * Variable set with cache by-pass
 */
function _ultimate_cron_variable_set($name, $value) {
  global $conf;
  db_merge('variable')->key(array('name' => $name))->fields(array('value' => serialize($value)))->execute();
  $conf[$name] = $value;
}

/**
 * Get cron queues and static cache them
 */
function _ultimate_cron_get_queues() {
  static $queues = NULL;
  if (!isset($queues)) {
    $queues = module_invoke_all('cron_queue_info');
    drupal_alter('cron_queue_info', $queues);
  }
  return $queues;
}

function ultimate_cron_module_name($module) {
  $file = drupal_get_path('module', $module) . '/' . $module . '.info';
  $info = drupal_parse_info_file($file);
  return $info['name'] ? $info['name'] : $module;
}



/**
 * Clean up log entries.
 */
function ultimate_cron_cleanup_log() {
  $query = db_select('ultimate_cron_log', 'l')
            ->fields('l', array('lid'))
            ->condition('start_time', time() - variable_get('ultimate_cron_cleanup_log', ULTIMATE_CRON_CLEANUP_LOG), '<');
  $total = $query->countQuery()->execute()->fetchField();
  $progress = 0;
  $process = BackgroundProcess::currentProcess();
  $process->setProgress(0);
  do {
    $lids = $query->range(0, 1000)
              ->execute()
              ->fetchAllKeyed(0, 0);
    if (!empty($lids)) {
      $progress += db_delete('ultimate_cron_log')
                     ->condition('lid', $lids, 'IN')
                     ->execute();
      $process->setProgress($progress / $total);
    }
  } while (!empty($lids));
  $process->setProgress(1);
}

/**
 * Run a cron hook.
 * Launches the cron job in a background process
 *
 * @param $name
 * @param $hook
 * @return mixed
 *   Connections file handle on success.
 */
function ultimate_cron_run_hook($hook, $skip_catch_up = FALSE) {
  // Run the job in background
  $result = NULL;
  $handle = "uc:" . $hook['name'];
  try {
    $process = BackgroundProcess::lock($handle);

    // Determine service group
    if (!empty($hook['service group'])) {
      $process->setServiceGroup($hook['service group']);
    }
    $hook['timestamp'] = time();
    unset($hook['background_process']);
    $process->setCallback('_ultimate_cron_run_hook', array($hook, $skip_catch_up));
    $process->setShutdownCallback('ultimate_cron_background_process_shutdown_callback', array($hook));
    $process->storeResult(FALSE);
    $process->call();
    return $process;
  }
  catch (Exception $e) {
    $process = BackgroundProcess::loadByHandle($handle);
    if ($process && $process->reDispatch()) {
      return $process;
    }
    throw $e;
  }
}

function ultimate_cron_run_hook_cli($hook, $skip_catch_up = FALSE) {
  // Run the job in background
  $result = NULL;
  $handle = "uc:" . $hook['name'];

  $process = BackgroundProcess::lock($handle);

  $hook['timestamp'] = time();
  unset($hook['background_process']);
  $process->setCallback('_ultimate_cron_run_hook', array($hook, $skip_catch_up));
  $process->setShutdownCallback('ultimate_cron_background_process_shutdown_callback', array($hook));
  $process->storeResult(FALSE);
  $process->runNow();
  return $process;
}

/**
 * Trigger a cron job.
 */
function ultimate_cron_trigger_cron_job($name, $skip_catch_up = FALSE) {
  $hooks = ultimate_cron_get_hooks();
  try {
    $process = ultimate_cron_run_hook($hooks[$name], $skip_catch_up);
    return TRUE;
  }
  catch (Exception $e) {
    return FALSE;
  }
}

/**
 * This is the function that is launched into a background process.
 * It runs the cron job and does housekeeping, pre/post execute hooks, etc.
 *
 * @param $hook
 *   Hook definition
 * @return boolean
 *   TRUE on success, FALSE on failure.
 */
function _ultimate_cron_run_hook($hook, $skip_catch_up = FALSE) {
  set_time_limit(variable_get('ultimate_cron_max_execution_time', ULTIMATE_CRON_MAX_EXECUTION_TIME));
  drupal_save_session(FALSE);

  // Load current process
  $process = BackgroundProcess::currentProcess();

  $log = &drupal_static('ultimate_cron_record_log', array('msg' => '', 'severity' => -1));
  $log = array('msg' => '', 'severity' => -1);
  $record = &drupal_static('ultimate_cron_record', FALSE);
  $record = TRUE;

  $time = time();
  if (FALSE && !$skip_catch_up && !ultimate_cron_hook_should_run($hook)) {
    // Hook started too late!
    watchdog('ultimate_cron', '%name skipped. Invoked at %invoke, but did not start until %start', array(
      '%name' => $hook['name'],
      '%invoke' => format_date($hook['timestamp'], 'custom', 'Y-m-d H:i:s'),
      '%start' => format_date($time, 'custom', 'Y-m-d H:i:s'),
    ), WATCHDOG_ERROR);
    return FALSE;
  }

  // Let other modules do stuff before execution, if they need to.
  module_invoke_all('cron_pre_execute', $hook);
  module_invoke_all('cron_pre_execute_' . $hook['name'], $hook);

  if (!empty($item['file'])) {
    require_once($item['file path'] . DIRECTORY_SEPARATOR . $item['file']);
  }

  if (is_callable($hook['callback'])) {
    $args = array_merge(array($hook), $hook['arguments']);
    call_user_func_array($hook['callback'], $args);
  }
  else {
    $process->keepAlive(FALSE);
    watchdog('ultimate_cron', '!callback for !name is invalid!', array('!callback' => $hook['callback'], '!name' => $hook['name']), WATCHDOG_CRITICAL);
  }

  // Let other modules do stuff after execution, if they need to.
  module_invoke_all('cron_post_execute', $hook);
  module_invoke_all('cron_post_execute_' . $hook['name'], $hook);

  return TRUE;
}

/**
 * Get a list of functions that should be run now.
 *
 * @param $hooks
 *   Array of cron hooks to check.
 * @return array
 *   Functions to run now.
 */
function ultimate_cron_get_schedule($hooks) {
  // Create list of scheduled functions
  $schedule = array();
  foreach ($hooks as $name => &$hook) {
    // Store last run in hook for sorting purposes
    $log = ultimate_cron_get_last_log_entry($name);
    $last_run = isset($log['start_time']) ? $log['start_time'] : 0;
    $hook['last_run'] = $last_run;

    if ($hook['background_process'] && $hook['background_process']->getStatus() == BACKGROUND_PROCESS_STATUS_RUNNING) {
      // If already running, then don't schedule
      continue;
    }

    if (ultimate_cron_hook_should_run($hook)) {
      $schedule[$name] = $hook;
    }
  }

  // Sort by last run time
  uasort($schedule, function ($a, $b) {
    return $a['last_run'] == $b['last_run'] ? 0 : ($a['last_run'] < $b['last_run'] ? -1 : 1);
  });

  // Allow other to manipulate the schedule
  drupal_alter('cron_schedule', $schedule);

  return $schedule;
}

/**
 * Check if a hook should be run now.
 *
 * @param array $hook
 * @return boolean
 */
function ultimate_cron_hook_should_run($hook) {
  // Is it enabled?
  if (empty($hook['enabled'])) {
    return FALSE;
  }

  $log = ultimate_cron_get_last_log_entry($hook['name']);
  $last_run = isset($log['start_time']) ? $log['start_time'] : 0;

  return ultimate_cron_should_run($hook['rules'], $last_run, time(), $hook['catch up'], $hook['original weight']);
}

/**
 * Sort callback for ordering schedule.
 *
 * @param type $a
 * @param type $b
 * @return type
 */
function _ultimate_cron_sort_schedule($a, $b) {
  return $a['last_run'] == $b['last_run'] ? 0 : ($a['last_run'] < $b['last_run'] ? -1 : 1);
}


function ultimate_cron_get_hook($name, $reset = FALSE) {
  $hooks = ultimate_cron_get_hooks($reset);
  return $hooks[$name];
}

/**
 * Get cron hooks available.
 *
 * @return array
 *   List of modules.
 */
function ultimate_cron_get_hooks($reset = FALSE) {
  static $hooks = NULL;
  if (!$reset && isset($hooks)) {
    return $hooks;
  }
  $hooks = array();
  $weight = 0;

  $settings = ultimate_cron_load_all();

  $query = db_select('background_process', 'b', array('target' => 'background_process'))
    ->fields('b')
    ->condition('handle', 'uc:%', 'LIKE');
  $processes = $query->execute()->fetchAllAssoc('handle', PDO::FETCH_OBJ);

  // Generate list of hooks
  $modules = module_list();
  foreach ($modules as $module) {
    // Get cronapi data
    $cron = module_invoke($module, 'cronapi', 'list');

    // Get default cron hook
    if (empty($cron["{$module}_cron"]) && module_hook($module, 'cron')) {
      $file = drupal_get_path('module', $module) . '/' . $module . '.info';
      $info = drupal_parse_info_file($file);
      $cron["{$module}_cron"] = array(
        'module' => $module,
        'description' => 'Default cron handler',
        'configure' => empty($info['configure']) ? NULL : $info['configure'],
      );
    }

    // Cleanup data
    if ($cron) {
      foreach ($cron as $name => &$item) {
        $defaults = $item;

        // Support old style cronapi :-(
        if (!is_array($item)) {
          $desc = $item;

          $rules = module_invoke($module, 'cronapi', 'rule', $name);
          $rules = is_array($rules) ? $rules : ($rules ? array($rules) : array());

          $defaults = (array)module_invoke($module, 'cronapi', 'settings', $name);
          if (empty($defaults['rules']) && $rules) $defaults['rules'] = $rules;

          $defaults += array(
            'description' => $desc,
            'configure' => module_invoke($module, 'cronapi', 'configure', $name),
          );
        }

        $defaults += array(
          'description' => $name,
          'module' => $module,
          'file path' => drupal_get_path('module', $module),
          'rules' => array(variable_get('ultimate_cron_rule', ULTIMATE_CRON_RULE)),
          'original weight' => $weight,
          'weight' => $weight,
          'arguments' => array(),
          'callback' => $name,
          'catch up' => variable_get('ultimate_cron_catch_up', ULTIMATE_CRON_CATCH_UP),
          'service group' => variable_get('ultimate_cron_service_group', ULTIMATE_CRON_SERVICE_GROUP),
          'enabled' => TRUE,
        );
        $weight++;

        $overloaded = empty($settings[$name]) ? array() : $settings[$name]->settings;
        $item = $overloaded + $defaults;
        $item['name'] = $name;
        $item['background_process'] = empty($processes['uc:' . $name]) ? NULL : BackgroundProcess::create($processes['uc:' . $name]);
        $item['defaults'] = $defaults;
        $item['settings'] = $overloaded;
      }
      $hooks += $cron;
    }
  }

  // Allow other to manipulate the hook list
  drupal_alter('cron', $hooks);

  // Sort by original weight
  uasort($hooks, function ($a, $b) {
    return $a['weight'] == $b['weight'] ? 0 : ($a['weight'] < $b['weight'] ? -1 : 1);
  });

  return $hooks;
}

/**
 * Store watchdog error messages for later use.
 *
 * @staticvar string $log
 * @param $msg
 *   Message to record.
 * @param $reset
 *   Reset recorded message.
 * @return string
 *   Message recorded.
 */
function ultimate_cron_record_log($msg = NULL, $severity = -1) {
  $log = &drupal_static('ultimate_cron_record_log', array('msg' => '', 'severity' => -1));
  if ($msg) {
    $log['msg'] .= "$msg\n";
  }
  if ($severity > 0) {
    if ($log['severity'] < 0 || $severity <= $log['severity']) {
      $log['severity'] = $severity;
    }
  }
  return $log;
}

// ---------- CRON RULE FUNCTIONS ----------

/**
 * Check if rule is valid.
 *
 * @param $rule
 *   rule to validate.
 * @return
 *   TRUE if valid, FALSE if not.
 */
function ultimate_cron_validate_rule($rule) {
  require_once 'CronRule.class.php';
  $cron = new CronRule($rule);
  if (!$cron->isValid()) {
    return FALSE;
  }
  else {
    return TRUE;
  }
}

/**
 * Check if rule is scheduled to run at a given time.
 *
 * @param $rules
 *   rules to validate.
 * @param $last_run
 *   last time the rule was run.
 * @param $now
 *   time of validation, set to NULL for now.
 * @param $catch_up
 *   run if we missed our time window?
 * @return boolean
 *   TRUE if rule is scheduled to run, FALSE if not.
 */
function ultimate_cron_should_run($rules, $last_run, $now = NULL, $catch_up = 0, $offset = 0) {
  $now = is_null($now) ? time() : $now;
  require_once 'CronRule.class.php';
  $cron = new CronRule();
  foreach ($rules as $rule) {
    $cron->rule = $rule;
    $cron->offset = $offset;
    $last_ran = $cron->getLastRan($now);
    if ($last_ran > $last_run && $last_ran >= $now - $catch_up) {
      return TRUE;
    }
  }
  return FALSE;
}

// ---------- CRUD/DB FUNCTIONS ----------

/**
 * Load settings for a cron job
 *
 * @param $name
 *
 * @return object
 *   Settings
 */
function ultimate_cron_load($name) {
  if (module_exists('ctools')) {
    ctools_include('export');
    $settings = ctools_export_crud_load('ultimate_cron', $name);
    if (!empty($settings->settings)) {
      $settings->settings = (array) $settings->settings;
    }
  }
  else {
    $settings = db_select('ultimate_cron', 'uc')
                  ->fields('uc')
                  ->condition('uc.name', $name)
                  ->execute()
                  ->fetchObject();
    if (!empty($settings->settings)) {
      $settings->settings = (array) unserialize($settings->settings);
    }
  }
  return $settings;
}

/**
 * CRUD save. Also used for ctools integration.
 * @param object $object
 *   object to be saved ->name containing unique machine name.
 * @return boolean
 *   result of query.
 */
function ultimate_cron_crud_save($object) {
  return db_merge('ultimate_cron')
    ->key(array('name' => $object->name))
    ->fields(array(
      'settings' => serialize($object->settings),
    ))
    ->execute();
}

/**
 * Save
 *
 * @param object $object
 *   object to be saved ->name containing unique machine name.
 * @return boolean
 *   result of query.
 */
function ultimate_cron_save($object) {
  if (module_exists('ctools')) {
    ctools_include('export');
    $settings = ctools_export_crud_new('ultimate_cron');
    $settings->name = $object->name;
    $settings->settings = $object->settings;
    return ctools_export_crud_save('ultimate_cron', $settings);
  }
  else {
    return ultimate_cron_crud_save($object);
  }
}

/**
 * Load all cronjob settings and processes.
 *
 * @return array
 *   Array of cronjobs and their data.
 */
function ultimate_cron_load_all() {
  if (module_exists('ctools')) {
    ctools_include('export');
    $settings = ctools_export_crud_load_all('ultimate_cron');
    #foreach ($settings as $info) {
      #$info->settings = !empty($info->settings) ? (array) unserialize($info->settings) : array();
    #}
  }
  else {
    $settings = db_select('ultimate_cron', 'u')
      ->fields('u', array('name', 'settings'))
      ->execute()
      ->fetchAllKeyed('name', PDO::FETCH_OBJ);
    foreach ($settings as $info) {
      $info->settings = $info->settings ? (array) unserialize($info->settings) : array();
    }
  }
  return $settings;
}

/**
 * Get latest log line for a function.
 *
 * @param $name
 *   Function to get latest log line for,
 * @return object
 *   Log line.
 */
function ultimate_cron_get_last_log_entry($name, $reset = FALSE) {
  static $logs = array();
  if (!$reset && isset($logs[$name])) {
    return $logs[$name];
  }

  $log = db_select('ultimate_cron_log', 'l')
           ->fields('l')
           ->condition('l.name', $name)
           ->orderBy('l.start_time', 'DESC')
           ->range(0, 1)
           ->execute()
           ->fetchAssoc();
  $logs[$name] = $log;
  return $log;

  // @fixme Only MySQL supports this?
  $logs = ultimate_cron_get_last_log_entries($reset);
  return isset($logs[$name]) ? $logs[$name] : array();
}

/**
 * Get latest log lines for all functions.
 *
 * @fixme Only MySQL supports this?
 */
function ultimate_cron_get_last_log_entries($reset = FALSE) {
  static $logs = NULL;
  if (!$reset && isset($logs)) {
    return $logs;
  }
  $logs = db_query("SELECT l.*
  FROM {ultimate_cron_log} l
  JOIN (
    SELECT l3.name, (
      SELECT l4.lid
      FROM {ultimate_cron_log} l4
      WHERE l4.name = l3.name
      ORDER BY l4.name desc, l4.start_time DESC
      LIMIT 1
    ) AS lid FROM {ultimate_cron_log} l3
    GROUP BY l3.name
  ) l2 on l2.lid = l.lid")->fetchAllAssoc('name', PDO::FETCH_ASSOC);
  return $logs;
}

// ---------- POORMAN FUNCTIONS ----------

/**
 * Launch poorman cron if it's time to do so.
 */
function ultimate_cron_trigger_poorman() {
  // Launch poormans cron if applicable
  if (variable_get('ultimate_cron_poorman', ULTIMATE_CRON_POORMAN)) {
    $last = variable_get('cron_last', 0);
    $last = floor($last / 60) * 60;
    $time = time();
    $time = floor($time / 60) * 60;
    // Don't attempt, if already run within last minute
    if ($last < $time) {
      $process = BackgroundProcess::loadByHandle('ultimate_cron_poorman');
      if (!$process || $process->getStatus() != BACKGROUND_PROCESS_STATUS_RUNNING) {
        ultimate_cron_trigger_cron_job('ultimate_cron_poorman');
      }
    }
  }
}

/**
 * The actual poorman function
 * @return type
 */
function ultimate_cron_poorman() {
  $process = BackgroundProcess::currentProcess();
  if (!variable_get('ultimate_cron_poorman', ULTIMATE_CRON_POORMAN)) {
    $process->keepAlive(FALSE);
    return;
  }

  // Derive current minute
  $time = time();
  $time = floor($time / 60) * 60;

  // Run the cron
  ultimate_cron_cron_run(TRUE);

  // Wait until end of "current" minute
  $wait = $time + 60 - time();
  if ($wait > 0 && $wait <= 60) {
    sleep($wait);
  }

  // Reload settings
  $hook = ultimate_cron_get_hook('ultimate_cron_poorman', TRUE);
  unset($hook['background_process']);
  $keepalive = $hook['enabled'] ? TRUE : FALSE;
  if ($keepalive) {
    if ($hook['service group']) {
      $process->setServiceGroup($hook['service group']);
    }
    // Relaunch with new hook settings and skip catch up!
    $process->setCallback($process->callback, array($hook, TRUE));
  }
  $process->keepAlive($keepalive);
}

